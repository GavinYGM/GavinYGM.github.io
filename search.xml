<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>绪论</title>
    <url>/2020/04/16/%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p>对特定问题求解步骤的一种描述。</p>
<h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><ul>
<li>有穷性：算法必须总是执行有穷步之后结束且每一步都在有穷时间内完成</li>
<li>确定性：每一条指令必须有确切的含义</li>
<li>可行性：算法是可行的</li>
<li>输入：有零个或多个输入</li>
<li>输出：有一个或多个输出</li>
</ul>
<h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><p>　　算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>　　算法执行时间的变化趋势可以表示为输入规模的一个函数，称作该算法的时间复杂度，记作$T(n)$。从保守估计的角度出发，$T(n)$就是所有输入中执行时间最长的。</p>
<h3 id="渐进复杂度"><a href="#渐进复杂度" class="headerlink" title="渐进复杂度"></a>渐进复杂度</h3><p>　　为什么要引出渐进复杂度？是因为在评价算法运行效率的时候，我们往往是可以忽略其处理小规模问题时的能力差异，转而去关注其在处理更大规模问题时的表现。因为小规模问题处理起来时间本来就少，故此时不同算法的实际效率差异并不明显；而在处理更大规模的问题的时候，效率的些许差异都将对实际执行效果产生巨大的影响。</p>
<p>　　所谓的的渐进分析就是着眼长远、更为注重时间复杂度的总体变化趋势和增长速度的策略和方法。</p>
<p>　　为了更好的度量和评价时间复杂度的渐进增长速度，引入三个符号：$O,\Omega,\Theta$来分别渐进分析一个算法的最好、最坏和平均情况。</p>
<h4 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h4><p>　　首先这是一个函数，函数就可以输入进去变量，然后输出经过函数处理过后的值，先给出下面的公式，然后再做推导。</p>
<script type="math/tex; mode=display">
T(n)=O(f(n)) \tag{1}</script><p>　　<strong>推导:</strong>具体地，若存在正的常数c和函数f(n)，使得对任何$n&gt;&gt;2$（n远大于2）都有</p>
<script type="math/tex; mode=display">
T(n)\leq c\cdot f(n) \tag{2}</script><p>则可认为在n足够大之后，f(n)给出了T(n)增长速度的一个渐进上界，也就是公式(1)。<strong>上面式子中的f(n)函数指的是算法中基本操作重复执行的次数是问题规模n的某个函数，也就是说f(n)代表了这个算法中所有语句执行次数的和。</strong></p>
<p>　　通俗的理解上面的两个式子，就得先知道O到底干了什么，首先它是一个函数，前面说了函数的话是会在里面执行一些操作，而<strong>O进行的操作就是把输入里面的变量做了这两种变化：1、所有的正的常数项系数可以忽略并等同于一；2、多项式中只保留最高次项。</strong>那就好理解公式(1)中为什么用等于号了，因为经过这两步变换后，输入O的变量自然会小于等于$c\cdot f(n)$,都小于等于的话就可认为$T(n)=O(f(n))$了。根据上面的定义，就可以得出大$O$的如下两个性质了</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(1)\ 对于任意的c>0,有O(f(n))=O(c\cdot f(n)) \\
&(2)\ 对于任意的常数a>b>0,有O(n^a+n^b)=O(n^a)
\end{aligned}</script><p>　　<strong>可以看出，大$O$记号的这些性质很好地体现了对函数总体渐进增长趋势的关注和刻画。</strong></p>
<p>　　一个例子，在冒泡排序算法中，最差的输入情况需要执行的基本操作不会超过$2(n-1)^2$次，表示为该算法的时间复杂度为</p>
<script type="math/tex; mode=display">
T(n)=O(2(n-1)^2)</script><p>根据大$O$记号的性质，就可以进一步简化和整理为</p>
<script type="math/tex; mode=display">
T(n)=O(2n^2-4n+2)=O(2n^2)=O(n^2)</script><h4 id="大-Omega-记号"><a href="#大-Omega-记号" class="headerlink" title="大$\Omega$记号"></a>大$\Omega$记号</h4><p>　　为了对算法的复杂度最好情况做出估计，需要借助另一个记号。如果存在正的常数c和函数 g(n)，使得对于任何n &gt;&gt; 2都有 </p>
<script type="math/tex; mode=display">
T(n)\geq c \cdot g(n)</script><p>就可以认为，在n足够大之后，g(n)给出了T(n)的一个渐进下界。此时，我们记之为</p>
<script type="math/tex; mode=display">
T(n)=\Omega(g(n))</script><p>与大O记号恰好相反，大$\Omega$记号是对算法执行效率的乐观估计——对于规模为n的任意输入，算法的运行时间都不低于$\Omega$(g(n))。比如， 即便在最好情况下，起泡排序也至少需要T(n) = $\Omega$(n)的计算时间。</p>
<h4 id="大-Theta-记号"><a href="#大-Theta-记号" class="headerlink" title="大$\Theta$记号"></a>大$\Theta$记号</h4><p>　　借助大O记号、大$\Omega$记号，可以对算法的时间复杂度作出定量的界定，亦即，从渐进的趋势看，T(n)介于$\Omega$(g(n))与O(f(n))之间。若恰巧出现g(n) = f(n)的情况，则可以使用另一记号来表示。</p>
<p>　　如果存在正的常数c1 &lt; c2和函数h(n)，使得对于任何n &gt;&gt; 2都有 </p>
<script type="math/tex; mode=display">
c_1\cdot h(n) \leq T(n) \leq c_2\cdot h(n)</script><p>就可以认为在n足够大之后，h(n)给出了T(n)的一个确界。此时，我们记之为： </p>
<script type="math/tex; mode=display">
T(n)=\Theta(h(n))</script><p>它是对算法复杂度的准确估计——对于规模为n的任何输入，算法的运行时间T(n)都与$\Theta$(h(n))同阶。</p>
<p><img src="/2020/04/16/%E7%BB%AA%E8%AE%BA/image-20200416182804052.png" alt="image-20200416182804052" style="zoom: 80%;"></p>
<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>　　由于算法的时间复杂度考虑的只是对于问题规模n的增长率，则在难以精确计算基本操作执行次数(或语句频度)的情况下，只需求出它关于n的增长率或阶即可。以下学习记录了几种常见数量级的时间复杂度。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Abbott的复仇</title>
    <url>/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=757" target="_blank" rel="noopener">UVA-816</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例输入：</span></span><br><span class="line"><span class="comment">3 1 N 3 3 </span></span><br><span class="line"><span class="comment">1 1 WL NR * </span></span><br><span class="line"><span class="comment">1 2 WLF NR ER * </span></span><br><span class="line"><span class="comment">1 3 NL ER * </span></span><br><span class="line"><span class="comment">2 1 SL WR NF * </span></span><br><span class="line"><span class="comment">2 2 SL WF ELF * </span></span><br><span class="line"><span class="comment">2 3 SFR EL * </span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">样例输出：</span></span><br><span class="line"><span class="comment">(3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>在做一道算法题目的时候，我认为真正地搞懂题目意思是非常重要的，题目搞不懂很可能会出现漏解的情况。我觉得从样例输入和输出出发，然后往题目中带，是比较好的理解方式。这道题目结合下图的理解如下：这个图我根据样例走了一遍，为防止混乱，先使用红色，当节点重复了再用蓝色，然后再用绿色，最终走到终点。</p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200415143834740.png" alt="image-20200415143834740" style="zoom:80%;"></p>
<p>​            首先看样例输入的第一行，一个起点坐标(3,1)<strong>代表第三行第一列</strong>，一个离开起点时的位置N<strong>代表离开起点时朝向上</strong>，一个终点坐标(3,3)<strong>代表第三行第三列</strong>。一开始的时候我是有点疑问的：为什么上图的最下面有两个点表示起点和终点和样例中的不太一样啊，可后来想了想，样例输出可以有很多的，题目中的图只代表了一种情况，<strong>所以不用管多余的点</strong>。</p>
<p>​            然后看每一个坐标，都有进入坐标的方向，即NEWS，分表表示上、右、左、下，LFR分别表示进入该点可以向左、直走、向右走。结合样例比如1 1 WL NR<code>*</code>，对应图中的(1,1)坐标点，表示当进入(1,1)时的方向，如果是W，即向左的话，那么此时你只能左转；如果进入(1,1)朝向向上的话，此时只能右转，输入<code>*</code>代表此节点的输入结束，接着读取下一行，然后输入0代表整个输入结束。</p>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><p>​            说是研究对象可能有点过了，这里我指的是在算法解决问题的过程中所定义的几个重要的变量，下面针对我认为很重要的变量解释一波。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、Node结构体：这是一个三元组，用来表示位于(r,c)位置，dir表示方向朝向</span></span><br><span class="line"><span class="comment">2、has_edge[r][c][dir][turn]数组：这个四维数组表示当前状态是(r,c,dir)，是否可以朝turn转向。初始化为0，设为1表示可以转向。</span></span><br><span class="line"><span class="comment">3、d[r][c][dir]数组：该数组表示记录当前状态的节点与初始化状态的节点的距离。该数组初始化为-1。并且起点为-1，与题目意思切合，起点的下一个位置才是初始状态，所以下一个位置为0，所以也可以认为d数组是用来记录移动次数的，每移动一个节点值加一。方便打印的时候从跟节点回溯。</span></span><br><span class="line"><span class="comment">4、p[r][c][dir]数组：该数组表示了(r,c,dir)在BFS树中的父节点，在BFS树中除了起点外，每个节点都有唯一一个父节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>对用来解决问题的函数方法先说明一下。</p>
<ul>
<li><p>read_case();该方法是将所有的输入转换到has_edge数组中，表示此状态下节点所允许的转向。结合上图的BFS树理解也就是在该节点状态下有几个分支可以走。</p>
</li>
<li><p>dir_id();将NESW四个方向转换为0~3整数，方便在数组中当下标使用。</p>
</li>
<li><p>turn_id();将FLR三个转向转换为0~2整数，方便在数组中当下标使用。</p>
</li>
<li><p>walk();这个函数极为巧妙，用来获取转向后的下一个状态。根据FLR三种不同的转向，如果转向为L，即向左转，那么就顺时针加三，比如此时朝向为S，转向为L，那么在现实中我们很容易想到就是E，但是利用代码的话就是(dir+3)%4，这里为什么要用加？这是因为用加的话取余就可以再次从头开始循环NESW，但是逻辑上应该是逆时针减一的;如果转向为R，即向右转，那么就顺时针加一；如果转向为F，那么dir方向不变。</p>
<p>可以画一下图，一下子就理解了，见下图。</p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200417212146564.png" alt="image-20200417212146564" style="zoom:50%;"></p>
</li>
<li><p>solve();利用BFS方法模拟走路，分别查看FLR三个转向能否走，也就是层次遍历的核心了。然后每走一步就在上面定义的数组中更新一下状态，并把当前满足条件的分支加入到队列中。思路见下图。</p>
</li>
</ul>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200417214024977.png" alt="image-20200417214024977" style="zoom: 67%;"></p>
<p>最终可得到类似下图的BFS层次树</p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200415183218122.png" alt="image-20200415183218122"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>​            下面就将详细的解题思路注释在代码中，有时候看代码比看文字理解起来更容易。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> r,c,dir;<span class="comment">//站在(r,c)点，面朝方向dir(0~3)分别表示N,E,S,W</span></span><br><span class="line">	Node(<span class="keyword">int</span> r=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>,<span class="keyword">int</span> dir=<span class="number">0</span>):r(r),c(c),dir(dir)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* dirs=<span class="string">"NESW"</span>;<span class="comment">//上0 右1 下2 左3 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* turns=<span class="string">"FLR"</span>;<span class="comment">//直行0 左转1 右转2</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//这两个数组用来根据朝向设置移动步数，0~3下标分别对应NESW </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> has_edge[maxn][maxn][<span class="number">4</span>][<span class="number">3</span>];<span class="comment">//节点可能的转向 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn][<span class="number">4</span>];<span class="comment">//记录此时与起点的距离 </span></span><br><span class="line">Node p[maxn][maxn][<span class="number">4</span>];<span class="comment">//记录此节点的直接父节点</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义起点坐标、离开起点时方向、初始状态坐标和终点坐标 </span></span><br><span class="line"><span class="keyword">int</span> r0,c0,dir,r1,c1,r2,c2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符NESW，方位的顺时针转为从0~3的整数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_id</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strchr</span>(dirs,c)-dirs;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将转向数组转为0~2的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">turn_id</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strchr</span>(turns,c)-turns;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入函数，初始化起点终点和每一个坐标的专线 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_case</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ch用来读取离开初始位置的方向,s用来读取每个节点可能的转向 </span></span><br><span class="line">	<span class="keyword">char</span> ch[maxn],s[maxn];</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%s%d%d"</span>,&amp;r0,&amp;c0,&amp;ch,&amp;r2,&amp;c2)!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	dir=dir_id(ch[<span class="number">0</span>]);</span><br><span class="line">	r1=r0+dr[dir];<span class="comment">//这个是离开起点的第一个位置，即初始状态 </span></span><br><span class="line">	c1=c0+dc[dir];</span><br><span class="line">	<span class="keyword">int</span> r,c;</span><br><span class="line">	<span class="built_in">memset</span>(has_edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(has_edge));	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> d=dir_id(s[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> t=turn_id(s[i]);</span><br><span class="line">				has_edge[r][c][d][t]=<span class="number">1</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据转向更新节点 </span></span><br><span class="line"><span class="function">Node <span class="title">walk</span><span class="params">(Node u,<span class="keyword">int</span> <span class="built_in">turn</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dir=u.dir;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">1</span>) dir=(dir+<span class="number">3</span>)%<span class="number">4</span>;<span class="comment">//如果转向为L，更新转向为顺时针数三个位置 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">2</span>) dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;<span class="comment">//如果转向为R，更新转向为顺时针数一个位置 </span></span><br><span class="line">	<span class="keyword">return</span> Node(u.r+dr[dir],u.c+dc[dir],dir); </span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">//判断数组是否出界</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> r&gt;=<span class="number">1</span>&amp;&amp;r&lt;=<span class="number">9</span>&amp;&amp;c&gt;=<span class="number">1</span>&amp;&amp;c&lt;=<span class="number">9</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//打印路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ans</span><span class="params">(Node u)</span></span>&#123;</span><br><span class="line">	<span class="comment">//从终点向起点添加到vector中，然后反向遍历输出路径 </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		nodes.push_back(u); </span><br><span class="line">		<span class="keyword">if</span>(d[u.r][u.c][u.dir]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//此时跳出循环，为初始状态节点，但不是起点 </span></span><br><span class="line">		u=p[u.r][u.c][u.dir];<span class="comment">//把这个节点的父节点找出来，再加入到向量中 </span></span><br><span class="line">	&#125;</span><br><span class="line">	nodes.push_back(Node(r0,c0,dir));<span class="comment">//记得把起点加入到vector中</span></span><br><span class="line">	<span class="comment">//最后反向遍历，每十个为一行输出路径</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span>=nodes.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">end</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d,%d) "</span>,nodes[i].r,nodes[i].c);</span><br><span class="line">		<span class="keyword">if</span>(++cnt%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>,nodes[<span class="number">0</span>].r,nodes[<span class="number">0</span>].c);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS层次数模拟走路 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="function">Node <span class="title">u</span><span class="params">(r1,c1,dir)</span></span>;<span class="comment">//走了一步之后的初始状态</span></span><br><span class="line">	d[u.r][u.c][u.dir]=<span class="number">0</span>;<span class="comment">//每走一步加一 </span></span><br><span class="line">	q.push(u);<span class="comment">//在这里先把初始状态放入队列，然后在while中操作 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		Node u=q.front();q.pop();</span><br><span class="line">		<span class="keyword">if</span>(u.r==r2&amp;&amp;u.c==c2)&#123;<span class="comment">//如果走到终点 </span></span><br><span class="line">			print_ans(u);<span class="comment">//打印路径 </span></span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//跳出solve函数 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不是终点的话就继续走我认为从这个for循环开始体现BFS的核心思想了 </span></span><br><span class="line">		<span class="comment">//循环三次0~2，表示能否转向FLR,在BFS层次树上体现的是遍历三个分支</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			Node v=walk(u,i);</span><br><span class="line">			<span class="keyword">if</span>(has_edge[u.r][u.c][u.dir][i]&amp;&amp;<span class="comment">//这里要看当前节点是否可以分支转向！！！ </span></span><br><span class="line">				inside(v.r,v.c)&amp;&amp;</span><br><span class="line">				d[v.r][v.c][v.dir]&lt;<span class="number">0</span>)&#123;<span class="comment">//这里小于0的意思是之前走过的路不能再走了，再走就闭合了 </span></span><br><span class="line">				d[v.r][v.c][v.dir]=d[u.r][u.c][u.dir]+<span class="number">1</span>;<span class="comment">//更新层次，在上一层的基础上加一，即到起点的距离加一 </span></span><br><span class="line">				p[v.r][v.c][v.dir]=u;<span class="comment">//把u作为v的直接父节点，v是u的下一步之后的要想清楚 </span></span><br><span class="line">				q.push(v);<span class="comment">//把下一步的节点放入队列，方便下一轮的BFS遍历 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//当没有走到终点的情况下队列为空了，就说明可能无解！ </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No solution possible\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(read_case())&#123;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下：</strong></p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200417224912902.png" alt="image-20200417224912902" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>算法入门</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建站过程</title>
    <url>/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>nodejs、本地Git bash安装、github注册等等这些之前在学习vue的时候都已经配置过了，所以我一上来就是直接配置Hexo的。</p>
<h2 id="本地搭建Hexo步骤"><a href="#本地搭建Hexo步骤" class="headerlink" title="本地搭建Hexo步骤"></a>本地搭建Hexo步骤</h2><h3 id="npm安装hexo"><a href="#npm安装hexo" class="headerlink" title="npm安装hexo"></a>npm安装hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p><strong><font style="color:red;">重点hexo安装慢和后面hexo init初始化慢的坑</font>：就是要给npm换源，换成国内的镜像源，我用过下面两种方法，建议第二种，因为后面初始化hexo init是要用npm的</strong></p>
<ul>
<li><p>使用阿里定制的 cnpm 命令行工具代替默认的 npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接把npm换为淘宝源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>输入<code>npm config list</code>可以查看是否换源成功</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414215447453.png" alt="image-20200414215447453.png"></p>
</li>
</ul>
<p>安装好了hexo后，接下来要先初始化一个本地项目，这点有点类似于git的操作。</p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><ul>
<li><p>首先我是先找了一个比较空的不常用的磁盘作为我的博客的建站地点，然后右击git bash打开git的命令行，并执行一下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p><strong>这个地方需要注意，可能到某个地方下载的特别慢，但是如果前面切换了npm，应该很快就好了，我当时觉得感觉到卡住了，所以搜了一下，但是删除这个项目的时候说.git文件正在使用中，然后在配置好了npm镜像源之后果断重启了电脑，然后删掉了项目，重新执行上面的命令</strong></p>
<p>完成了之后会出现在本地下载好如下内容(确实有点像vue)，但是在接下来的各种操作，只需要关注下面几个文件夹就好了。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414194329012.png" alt="image-20200414194329012" style="zoom:80%;"></p>
</li>
<li><p>生成静态页面——-在以上文件夹的public中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动本地服务器——-<code>浏览器输入：http://localhost:4000/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭本地服务器——-<code>Ctrl+c</code></p>
<p><strong>以上命令都是在git bash，也就写git命令的地方执行。执行完以上操作，基本上就完成了本地hexo的搭建，但是他那个界面我不太喜欢，所以还是参考大神博客修改了一番，接下来就开始漫长的博客主题设置模块</strong></p>
</li>
</ul>
<h2 id="博客主题配置"><a href="#博客主题配置" class="headerlink" title="博客主题配置"></a>博客主题配置</h2><h3 id="克隆别人的主题"><a href="#克隆别人的主题" class="headerlink" title="克隆别人的主题"></a>克隆别人的主题</h3><p>在刚刚hexo init的项目根目录下找到themes文件夹，进去右击git bash，在此处clone别人的github中的主题，我用的是hexo-theme-next，后面有喜欢的主题我也会试着修改一下，暂时先用着这个，简洁清新，很不错~。当然还有很多好看的主题可以到这个页面<code>https://hexo.io/themes/</code>，点击一个喜欢的主题，然后进去点击人家的github链接，复制github中的链接同样的命令克隆到themes文件夹下即可。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>  下载可能需要等一会，这个等候是在自己的承受范围的哈哈哈，毕竟github是国外的，速度比较慢。下载完在themes文件夹下会多出一个文件夹，建议把这些文件夹先搞明白，不管我们写什么项目，先把常用的文件夹弄清楚我觉得是很有必要的，虽然我一开始被弄得有点乱，但是现在回想起来好像也就那几个目录常用。</p>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><ul>
<li><p>现在要回到刚刚hexo init的根目录下，然后用记事本打开_config.yml文件，我是用的nodepad++打开的，有高亮而且格式不会乱。这个yml接下来会常用到，毕竟是配置文件，和springboot中的配置文件一样，之前了解过，在启动的时候会自己加载。</p>
</li>
<li><p>然后notepad++中<code>Ctrl+f</code>，搜索theme，然后修改为刚刚的克隆的主题的名称</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414200852111.png" alt="image-20200414200852111" style="zoom:80%;"></p>
</li>
</ul>
<h3 id="切换主题风格"><a href="#切换主题风格" class="headerlink" title="切换主题风格"></a>切换主题风格</h3><ul>
<li><p>这个主题包中应该是自带了几种风格的，进入到这个包中，可以看到如下文件，当然也并不是全部用得到。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414201943868.png" alt="image-20200414201943868" style="zoom: 67%;"></p>
</li>
<li><p>进入配置文件修改主题风格，用notepad++打开改目录下的_config.yml，<strong>建议notepad++在整个过程中就不要关闭了，而且要记住这两个配置文件，哪个是项目根目录的配置文件，哪个是克隆的主题包的配置文件。</strong></p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414203008492.png" alt="image-20200414203008492" style="zoom:67%;"></p>
</li>
<li><p>然后修改主题风格如下，人家包中就注释好了几种，只要稍微改一下就好了，直接<code>Ctrl+f</code>搜索<code>scheme</code>，这里我用的是下面的风格</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414203200798.png" alt="image-20200414203200798" style="zoom:80%;"></p>
</li>
</ul>
<h3 id="博客左侧导航栏设置"><a href="#博客左侧导航栏设置" class="headerlink" title="博客左侧导航栏设置"></a>博客左侧导航栏设置</h3><ul>
<li>进入根目录的_config.yml，打开后在最上面可以修改博客的导航栏</li>
</ul>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414204645233.png" alt="image-20200414204645233" style="zoom:80%;"></p>
<ul>
<li><p>注意一下language是切换语言为中文的，其他的直接看下效果就好了</p>
</li>
<li><p>导航栏从上往下来，下面就是专栏的设计，也就是首页和归档等，这里我先添加两个专栏，一个是分类，一个是标签。</p>
<h4 id="分类专栏"><a href="#分类专栏" class="headerlink" title="分类专栏"></a><strong>分类专栏</strong></h4><ul>
<li><p>回到项目的根目录下，也就是刚刚hexo init生成的目录，然后在这里右击git bash，输入下面的命令，就会在项目根目录的source文件夹下自动创建一个categories文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开categories文件夹中的index.md文件，添加下面一行，<font style="color:red;"><strong>冒号后面要有个空格</strong></font></p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414205701409.png" alt="image-20200414205701409"></p>
</li>
<li><p>然后到<code>MyBlog\themes\hexo-theme-next</code>主题文件夹下的_config.xml中，<code>Ctrl+f</code>搜索menu，然后把categories一行取消注释，也就是去掉前面的#。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414210210966.png" alt="image-20200414210210966" style="zoom:80%;"></p>
</li>
<li><p>将文章添加到分类——后面会详细说一下发布文章的整个步骤，这就先提一下，也就是在md文档的最顶端添加一行即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: 建站</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="标签专栏"><a href="#标签专栏" class="headerlink" title="标签专栏"></a><strong>标签专栏</strong></h4><ul>
<li><p>和分类专栏步骤差不多，首先在根目录下执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开tags文件夹中的index.md文件,添加一行</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414210713648.png" alt="image-20200414210713648"></p>
</li>
<li><p>然后到主题文件夹下的配置文件中取消注释的tags一行即可</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414210821050.png" alt="image-20200414210821050" style="zoom:80%;"></p>
</li>
<li><p>给文章添加标签，需要注意文章可能有多个标签，所以要用以下方式,记得-后面有个空格！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">	- Hexo</span><br><span class="line">	- Github</span><br><span class="line">	- 腾讯云域名</span><br><span class="line">	- Windows</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加到文章的标签样式，默认标签在文章最下面，标签前面有一个#，要改成一个图标才好看，所以要进去主题文件夹下<code>\MyBlog\themes\hexo-theme-next\layout\_macro</code>，打开post.swig文件，这个文件就类似于我们的HTML文件，进去后<code>Ctrl+f</code>搜索<code>tag_indicate</code>,这里不知道为啥他用了if判断，我根据我的直觉，直接把带有#的那部分删掉了，也就是一出来就让他显示那个图标签的图标就好。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414225232228.png" alt="image-20200414225232228" style="zoom: 67%;"></p>
<h4 id="站内搜索专栏"><a href="#站内搜索专栏" class="headerlink" title="站内搜索专栏"></a><strong>站内搜索专栏</strong></h4></li>
<li><p>这个地方按照别人的博客来搞，最后部署的时候竟然会出现以下问题，显示乱了，在本地访问是没有问题的。<strong>可能是因为我安装的时候不是在根目录下安装的插件</strong></p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414212415442.png" alt="image-20200414212415442" style="zoom:67%;"></p>
<p><strong>解决方法:</strong>在hexo init的项目根目录下，按住shift键右击鼠标，然后在这里打开powershell命令行，然后执行下面的命令，安装站内搜索插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414212727263.png" alt="image-20200414212727263"></p>
</li>
<li><p>按装好了后在项目根目录的_config.yml文件的最下面添加下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入主题文件夹的_config.yml文件，<code>Ctrl+f</code>搜索<code>local_search</code>，设置enable为true</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414213131759.png" alt="image-20200414213131759" style="zoom:80%;"></p>
<h4 id="个人头像设置"><a href="#个人头像设置" class="headerlink" title="个人头像设置"></a><strong>个人头像设置</strong></h4></li>
<li><p>打开主题文件夹下的_config.yml,然后<code>Ctrl+f</code>搜索<code>avatar</code>，然后把一个头像链接替换即可。</p>
</li>
<li><p><strong><font style="color:red;">这里头像链接的一定要注意</font></strong></p>
<p>需要在hexo init项目根目录的source文件夹下新建一个images文件夹，然后把图片放到里面，然后在填写路径的时候，直接写相对路径<code>&quot;/images/1.jpg&quot;</code>，</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414230547359.png" alt="image-20200414230547359" style="zoom:80%;"></p>
<p>我通过调试工具发现，开启服务器后，<code>http://localhost:4000/</code>所请求到的文件夹就是项目根目录的source文件夹，所以上面直接从images目录写就好了。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414230705922.png" alt="image-20200414230705922" style="zoom:80%;"></p>
</li>
<li><p>给头像加样式，设置旋转以及圆角(因为我的头像是长方形，所以就不设置圆角了)，进入主题文件夹下的<code>\MyBlog\themes\hexo-theme-next\source\css\_common\components</code>目录，打开<code>components.styl</code>，在这里需要解释一波，这里的.styl文件，就和HTML的样式表文件.css文件是同样的效果！然后我们在这个文件下面加入下面的代码，就可以实现圆角和hover时旋转360°了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">#333</span>sf;</span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@-moz-keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后重启服务器，可以看到经过以上配置后，博客左侧导航栏的初步样式，当然也可以边设置边重新启动来看效果。重启的步骤就是先<code>Ctrl+c</code>关闭服务器，如果正在运行的话，然后hexo g重新生成静态文件，最后hexo s启动服务器，以上两个命令如果没有效果可以先hexo clean一波，然后再试</strong>。效果如下：</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414231818624.png" alt="image-20200414231818624" style="zoom:67%;"></p>
<h3 id="博客底部设置"><a href="#博客底部设置" class="headerlink" title="博客底部设置"></a>博客底部设置</h3></li>
</ul>
<h4 id="去掉底部自带的Hexo链接"><a href="#去掉底部自带的Hexo链接" class="headerlink" title="去掉底部自带的Hexo链接"></a>去掉底部自带的Hexo链接</h4><ul>
<li><p>打开<code>MyBlog\themes\hexo-theme-next\layout\_partials</code>下的footer.swig，这个文件就相当于html文件，然后我是把下面那部分内容去掉了</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414235113905.png" alt="image-20200414235113905" style="zoom:80%;"></p>
</li>
</ul>
<h4 id="网站底部字数统计设置"><a href="#网站底部字数统计设置" class="headerlink" title="网站底部字数统计设置"></a>网站底部字数统计设置</h4><ul>
<li><p>在项目根目录下安装 hexo 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>MyBlog\themes\hexo-theme-next\layout\_partials</code>下的footer.swig，在文末添加下面的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>博客全站共&#123;&#123; totalcount(site) &#125;&#125;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="网站底部站点访问量和访问人数"><a href="#网站底部站点访问量和访问人数" class="headerlink" title="网站底部站点访问量和访问人数"></a>网站底部站点访问量和访问人数</h4><p>​        <strong>需要注意的是，访问次数和浏览量在本地服务器会出现次数非常大的状况，这是小问题，只要部署在github之后，就不会有这个问题啦</strong></p>
<ul>
<li><p>网站底部字数统计设置已经安装了插件，这里不需要再装</p>
</li>
<li><p>然后打开<code>MyBlog\themes\hexo-theme-next\layout\_partials</code>下的footer.swig，在文末添加下面的代码，<strong>这段代码加在字数统计的上面</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user-md"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span></span><br><span class="line">    本站访问量:<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span><br><span class="line">    本站总访客量：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414235846523.png" alt="image-20200414235846523" style="zoom: 67%;"></p>
</li>
</ul>
<h3 id="文章阅读次数设置"><a href="#文章阅读次数设置" class="headerlink" title="文章阅读次数设置"></a>文章阅读次数设置</h3><p><strong>我参考的博客中的方法是不行的</strong>，而且我查阅了很多博客几乎都是这样，都不行。也就是说<strong>不用把busuanzi_count:设置为true</strong>，只是用HTML的代码就可以实现了。</p>
<p><strong>解决方法：</strong>找到<code>MyBlog\themes\hexo-theme-next\layout\_macro</code>下的post.swig，根据我的理解，这就是每篇文章的布局，相当于文章的HTML文件，然后我进去找，凭借感觉真的发现了问题所在，原来在if判断的时候出了问题，我也是歪打正着，下面删掉了判断中的部分就好了</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415000958172.png" alt="image-20200415000958172"></p>
<p><strong>以上是我在配置博客主题的时候遇到问题的地方吧，文章最后会给出参考链接，链接中给我遇到问题的地方都已经给出了，还有一些我没有用到的效果，可以自行使用，问题都不大啦！！！</strong></p>
<h2 id="部署到github远程仓库"><a href="#部署到github远程仓库" class="headerlink" title="部署到github远程仓库"></a>部署到github远程仓库</h2><h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><p>这里需要注意创建仓库的名称一定要是<code>你的github名称.github.io</code></p>
<h3 id="链接到本地hexo"><a href="#链接到本地hexo" class="headerlink" title="链接到本地hexo"></a>链接到本地hexo</h3><ul>
<li><p>复制github仓库的链接</p>
</li>
<li><p>打开项目根目录的_config.yml文件，<code>Ctrl+f</code>搜索<code>deploy</code>，<strong>tpye</strong> 设置为 <strong>git</strong>，<strong>repo</strong> 则设置为刚刚新建的远程仓库链接。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415003907761.png" alt="image-20200415003907761" style="zoom:80%;"></p>
</li>
<li><p>然后在项目根目录下安装插件，<strong>记住一定是根目录！！！前面好几处错误都不是根目录导致的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在根目录下执行代码部署到github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #这句是清除所有本地的静态文件</span><br><span class="line">hexo g  #再生成所有静态文件</span><br><span class="line">hexo d  #部署到远程仓库</span><br></pre></td></tr></table></figure>
<p>然后就可以看到github仓库中有了内容，但是这样还不行，这样访问链接的话是没有一点样式的，还需要在本地hexo项目根目录下的_config.ym文件中，<code>Ctrl+f</code>搜索url，然后把github仓库的setting中的链接填写到下面的位置</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415004808091.png" alt="image-20200415004808091" style="zoom: 50%;"></p>
</li>
</ul>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415004858384.png" alt="image-20200415004858384" style="zoom: 67%;"></p>
<ul>
<li>然后再重新部署整个项目，即可看到成功搭建完成了！！！最后需要注意，当你hexo d之后会发现自己的网站并没有及时更新，这时候可以再hexo d一遍，多刷新几下网站就出来啦！</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        总的来说，搭建个人博客的过程确实有点麻烦，可能还不如直接注册个别的博客来写，可是我觉得最大的好处就是这个写文章以及发表还有主题效果是真的好，最重要的这是个人博客！以后我会将自己在学习中所遇到的问题以及学到的新知识都会记录在这里，之前我都是记录在OneNote中，OneNote是我用了好几年的记笔记软件，但是它的格式什么的确实让我难受了许久(比如没有代码块等)。</p>
<p>​        我曾经也有过自己开发一个个人博客的想法,但是考虑到自己能力不足，也没有大块的时间去开发，而且部署在各大平台的云服务器还是要收费的，到期了就不能永久存留了，这个就一直拖再拖。直到我了解了hexo之后，我才发现用这个记笔记也是个很不错的选择，至少代码可以永久存在github。以后有时间的话我会把以前记录在OneNote的所有笔记整理到这里来，既可以温故而知新，又可以多备份一份笔记，防止笔记丢失了哈哈哈哈！！！</p>
<h2 id="本文参考链接"><a href="#本文参考链接" class="headerlink" title="本文参考链接"></a>本文参考链接</h2><p><a href="https://blog.csdn.net/weidong_y/article/details/90904781" target="_blank" rel="noopener">https://blog.csdn.net/weidong_y/article/details/90904781</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex使用过的公式记录</title>
    <url>/2020/04/17/Latex%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Latex公式要注意的地方"><a href="#Latex公式要注意的地方" class="headerlink" title="Latex公式要注意的地方"></a>Latex公式要注意的地方</h2><h3 id="希腊字母大小写"><a href="#希腊字母大小写" class="headerlink" title="希腊字母大小写"></a>希腊字母大小写</h3><p>比如omege，小写是$\omega$,大写是$\Omega$,大写只需要首字母开头大写即可，像这样<code>\omega</code>——<code>\Omega</code>。</p>
<h3 id="公式块内换行左对齐"><a href="#公式块内换行左对齐" class="headerlink" title="公式块内换行左对齐"></a>公式块内换行左对齐</h3><ul>
<li><p>一种是后面自动加了行号，用的是<code>align</code>，换行是<code>\\</code>,左对齐是每一行前面加<code>&amp;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">&amp;(1)\ 对于任意的c&gt;0,有O(f(n))&#x3D;O(c\cdot f(n)) \\</span><br><span class="line">&amp;(2)\ 对于任意的常数a&gt;b&gt;0,有O(n^a+n^b)&#x3D;O(n^a)</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{align}
&(1)\ 对于任意的c>0,有O(f(n))=O(c\cdot f(n)) \\
&(2)\ 对于任意的常数a>b>0,有O(n^a+n^b)=O(n^a)
\end{align}</script></li>
</ul>
<ul>
<li><p>一种是后面不加行号，用的是<code>aligned</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">&amp;(1)\ 对于任意的c&gt;0,有O(f(n))&#x3D;O(c\cdot f(n)) \\</span><br><span class="line">&amp;(2)\ 对于任意的常数a&gt;b&gt;0,有O(n^a+n^b)&#x3D;O(n^a)</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{aligned}
&(1)\ 对于任意的c>0,有O(f(n))=O(c\cdot f(n)) \\
&(2)\ 对于任意的常数a>b>0,有O(n^a+n^b)=O(n^a)
\end{aligned}</script></li>
<li><p><strong>以上两种方式在typora Markdown编辑器中我还真没看出啥区别，但是上传到博客中确实没有了行号。</strong></p>
</li>
</ul>
<h2 id="LaTeX使用链接"><a href="#LaTeX使用链接" class="headerlink" title="LaTeX使用链接"></a>LaTeX使用链接</h2><p><a href="https://www.jianshu.com/p/4460692eece4" target="_blank" rel="noopener">https://www.jianshu.com/p/4460692eece4</a></p>
<p><a href="https://blog.csdn.net/qq_18150255/article/details/88040858" target="_blank" rel="noopener">https://blog.csdn.net/qq_18150255/article/details/88040858</a></p>
<p><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">https://www.jianshu.com/p/a0aa94ef8ab2</a></p>
]]></content>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
</search>
