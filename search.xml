<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python基础知识笔记</title>
    <url>/2020/04/18/python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串拼接整数"><a href="#字符串拼接整数" class="headerlink" title="字符串拼接整数"></a>字符串拼接整数</h3><p>直接用+是不行的，需要先将int转为str在转换才行</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><a href="https://www.cnblogs.com/zqifa/p/python-list.html" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k1*k2)]</span><br></pre></td></tr></table></figure>
<h3 id="获取元素，没有返回默认值"><a href="#获取元素，没有返回默认值" class="headerlink" title="获取元素，没有返回默认值"></a>获取元素，没有返回默认值</h3><p><a href="https://www.itranslater.com/qa/details/2326060653032768512" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按照Python的精神，“要求宽恕，而不是允许”，这是一种方法：</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    b = a[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    b = <span class="string">'sss'</span></span><br><span class="line"><span class="comment">#本着“寻求许可，而不是宽恕”的非Python精神，这是另一种方式：</span></span><br><span class="line">b = a[<span class="number">4</span>] <span class="keyword">if</span> len(a) &gt; <span class="number">4</span> <span class="keyword">else</span> <span class="string">'sss'</span></span><br></pre></td></tr></table></figure>
<p>解题实践—-<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/25/math/63/" target="_blank" rel="noopener">罗马数字转整数</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h3><p><strong>注意一点，负号是从右往左索引，最右边是-1</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 索引从0开始，含左不含右</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[4]='</span>, mylist[<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[-4]='</span>, mylist[<span class="number">-4</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[0:4]='</span>, mylist[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[:4]='</span>, mylist[:<span class="number">4</span>])<span class="comment">#这里是从最左端到4索引</span></span><br><span class="line">print( <span class="string">'[4:]='</span>, mylist[<span class="number">4</span>:])<span class="comment">#这里是从4索引到最右端</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[0:4:2]='</span>, mylist[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>])<span class="comment">#这里是从0~4每隔2索引</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[-5:-1:]='</span>, mylist[<span class="number">-5</span>:<span class="number">-1</span>:])<span class="comment">#从-5到-1索引全部</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[-2::-1]='</span>, mylist[<span class="number">-2</span>::<span class="number">-1</span>])<span class="comment">#从-2到最左端，每隔-1索引</span></span><br></pre></td></tr></table></figure>
<h3 id="range-使用"><a href="#range-使用" class="headerlink" title="range()使用"></a>range()使用</h3><p>生成一列数，但是类型是<code>&lt;class &#39;range&#39;&gt;</code>，所以在使用的时候需要根据自己所需的类型转换一下，下面有几种用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换类型</span></span><br><span class="line">list(range(<span class="number">10</span>))</span><br><span class="line"><span class="comment">#使用列表生成式</span></span><br><span class="line">x=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment">#用在循环中当索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h3 id="打乱列表元素"><a href="#打乱列表元素" class="headerlink" title="打乱列表元素"></a>打乱列表元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#调用随机库中的shuffle函数</span></span><br><span class="line">x=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(x)</span><br><span class="line">random.shuffle(x)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<h3 id="列表的几种生成式"><a href="#列表的几种生成式" class="headerlink" title="列表的几种生成式"></a>列表的几种生成式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种</span></span><br><span class="line">x=[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment">#第二种带if</span></span><br><span class="line">x=[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">21</span>) <span class="keyword">if</span> x%<span class="number">2</span>]</span><br><span class="line"><span class="comment">#第三种两个for</span></span><br><span class="line">x=[m + n <span class="keyword">for</span> m <span class="keyword">in</span><span class="string">'ABC'</span><span class="keyword">for</span> n <span class="keyword">in</span><span class="string">'XYZ'</span>]</span><br><span class="line"><span class="comment">#第四种字典键值对</span></span><br><span class="line">    x=[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第四种需要注意：如果是字符串+int型的表达式，会报错，如下面这种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heights = &#123;<span class="string">'Yao'</span>:<span class="number">226</span>, <span class="string">'Sharq'</span>:<span class="number">216</span>, <span class="string">'AI'</span>:<span class="number">183</span>&#125;</span><br><span class="line">x=[k+<span class="string">'='</span>+ v <span class="keyword">for</span> k,v <span class="keyword">in</span> heights.items()]</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment">#TypeError: must be str, not int</span></span><br><span class="line"><span class="comment">#要先将int转为str类型</span></span><br><span class="line">x=[k+<span class="string">'='</span>+ str(v) <span class="keyword">for</span> k,v <span class="keyword">in</span> heights.items()]</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表生成式生成二维列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[_init_x(i, j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, dim_j)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, dim_i)]</span><br><span class="line"><span class="comment">#可以理解一下一维的[x**2 for x in range(5)]就是在前面的x**2循环5次生成五个数组成一维向量</span></span><br><span class="line"><span class="comment">#那同样可以扩展到二维，先看最外层，也就是要在前面生成一个列表，循环几次就生成几个列表，然后列表中的元素再利用列表生成式来生成</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组类似列表，元组里面的元素也是进行索引计算。列表里面的元素的值可以修改，而元组里面的<strong>元素的值不能修改，只能读取</strong>。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Python中集合主要有两个功能，一个功能是进行集合操作，另一个功能是消除重复元素。</p>
<h3 id="把字符串拆分为单个字符"><a href="#把字符串拆分为单个字符" class="headerlink" title="把字符串拆分为单个字符"></a>把字符串拆分为单个字符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">"abcnmaaaaggsng"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a='</span>, a)</span><br></pre></td></tr></table></figure>
<h3 id="set没有sort方法"><a href="#set没有sort方法" class="headerlink" title="set没有sort方法"></a>set没有sort方法</h3><p><strong>AttributeError</strong>: ‘set’ object has no attribute ‘sort’</p>
<h3 id="set方法只能传一个值哦"><a href="#set方法只能传一个值哦" class="headerlink" title="set方法只能传一个值哦"></a>set方法只能传一个值哦</h3><p>所以可以把列表或者元组转为集合，但不能直接在set方法里面赋多个值，比如下面是错误的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=set(<span class="string">'hello'</span>,<span class="string">'world'</span>)<span class="comment">#**TypeError**: set expected at most 1 arguments, got 2</span></span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="获取字典的keys和values"><a href="#获取字典的keys和values" class="headerlink" title="获取字典的keys和values"></a>获取字典的keys和values</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print( k.keys())</span><br><span class="line">print( k.values())</span><br></pre></td></tr></table></figure>
<h3 id="字典的get和pop"><a href="#字典的get和pop" class="headerlink" title="字典的get和pop"></a>字典的get和pop</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k.get(<span class="string">'edu'</span>, <span class="number">-1</span>) <span class="comment"># 通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value</span></span><br><span class="line">k.pop(<span class="string">'like'</span>)<span class="comment">#删除字典元素</span></span><br></pre></td></tr></table></figure>
<h3 id="用zip生成字典"><a href="#用zip生成字典" class="headerlink" title="用zip生成字典"></a>用zip生成字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zl = zip((<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># zip可以将列表、元组、集合、字典‘缝合’起来</span></span><br></pre></td></tr></table></figure>
<h3 id="字典的遍历方法"><a href="#字典的遍历方法" class="headerlink" title="字典的遍历方法"></a>字典的遍历方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种</span></span><br><span class="line">heights = &#123;<span class="string">'Yao'</span>:<span class="number">226</span>, <span class="string">'Sharq'</span>:<span class="number">216</span>, <span class="string">'AI'</span>:<span class="number">183</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> heights:</span><br><span class="line">    <span class="keyword">print</span> (i, heights[i])<span class="comment">#单独打印i的话就只有key</span></span><br><span class="line"><span class="comment">#第二种</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> heights.items():</span><br><span class="line">    print(key, value)</span><br></pre></td></tr></table></figure>
<h3 id="初始化字典"><a href="#初始化字典" class="headerlink" title="初始化字典"></a>初始化字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dict3=dict(zip([0 for _ in range(k1*k2)],[0.0 for _ in range(k1*k2)]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#setdefault,用法如下： dict.setdefault(key,[这里设置如果不存在想将值设置为啥，默认为None])</span></span><br></pre></td></tr></table></figure>
<h3 id="给字典排序"><a href="#给字典排序" class="headerlink" title="给字典排序"></a>给字典排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>把另一个函数作为参数传入一个函数，这样的函数称为高阶函数。函数本身也可以赋值给变量，函数与其它对象具有同等地位。</p>
<h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><p>将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。这个map函数的参数列表有两个，第一个是自己传一个函数，第二个是列表类型。</p>
<p><strong>自己传入的函数只有一个参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myList = [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">map(abs, myList)</span><br></pre></td></tr></table></figure>
<h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce把一个函数作用在一个序列[x1, x2, x3…]上，<strong>这个函数必须接收两个参数</strong>，<strong>reduce把结果继续和序列的下一个元素做累积计算</strong>，<strong>使用的时候要先导包</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="comment">#累计求和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addsum</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">mylist=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">ans=reduce(addsum,mylist)</span><br></pre></td></tr></table></figure>
<h3 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h3><p>把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。是True的话过滤掉，是False的话留下。但是要知道filter函数返回的是一个filter对象，如果要看到列表结果还需要自己转换类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x%<span class="number">2</span></span><br><span class="line">m=filter(is_odd,mylist)</span><br><span class="line">list(m)</span><br></pre></td></tr></table></figure>
<h3 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h3><p>实现对序列排序，默认情况下对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1。可以自定义判断函数，然后传入sorted，传入函数包含两个参数，返回值是bool类型。**在c++中的算法库中sort也有类似用法。</p>
<p>默认排序：数字大小或字母序（针对字符串），<strong>但是要注意sorted是不会对原来的列表进行修改的，通过返回值生成一个新的排序后的列表，这点与c++不同</strong></p>
<p>也可以使用 list 的 list.sort() 方法。这个方法会修改原始的 list（返回值为None）。通常这个方法不如sorted()方便-如果你不需要原始的 list，list.sort()方法效率会稍微高一些</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted(myList)</span><br></pre></td></tr></table></figure>
<p><strong>Python3中sorted 语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted(iterable, key&#x3D;None, reverse&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>iterable — 可迭代对象。</li>
<li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li>reverse — 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#比如一个列表中存放好几个元组，要求自定义对元组的排序，这下只能通过使用指定key来比较</span></span><br><span class="line">L=[(<span class="string">'b'</span>,<span class="number">2</span>),(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'c'</span>,<span class="number">3</span>),(<span class="string">'d'</span>,<span class="number">4</span>)]</span><br><span class="line">sorted(L,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])<span class="comment">#指定key为比较每个元组中的第二个元素的大小，然后进行排序，默认为升序，可以通过reverse 设置,这里的lambda函数可以这样理解：因为只有一个参数x，所以即把里表中的每一个元素传入函数，然后对其取值。</span></span><br></pre></td></tr></table></figure>
<p><strong>当然也可以自定义函数来实现python2中的sorted方法</strong>，文末有链接</p>
<p>比如下面的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="comment">#可以使用cmp_to_key函数转换一下</span></span><br><span class="line">sorted(L,key=cmp_to_key(<span class="keyword">lambda</span> x,y:x[<span class="number">1</span>]-y[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_37295506/article/details/86542926" target="_blank" rel="noopener">关于python2和python3中高阶函数sorded的变换</a></p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex使用过的公式记录</title>
    <url>/2020/04/17/Latex%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Latex公式要注意的地方"><a href="#Latex公式要注意的地方" class="headerlink" title="Latex公式要注意的地方"></a>Latex公式要注意的地方</h2><h3 id="希腊字母大小写"><a href="#希腊字母大小写" class="headerlink" title="希腊字母大小写"></a>希腊字母大小写</h3><p>比如omege，小写是$\omega$,大写是$\Omega$,大写只需要首字母开头大写即可，像这样<code>\omega</code>——<code>\Omega</code>。</p>
<h3 id="公式块内换行左对齐"><a href="#公式块内换行左对齐" class="headerlink" title="公式块内换行左对齐"></a>公式块内换行左对齐</h3><ul>
<li><p>一种是后面自动加了行号，用的是<code>align</code>，换行是<code>\\</code>,左对齐是每一行前面加<code>&amp;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">&amp;(1)\ 对于任意的c&gt;0,有O(f(n))&#x3D;O(c\cdot f(n)) \\</span><br><span class="line">&amp;(2)\ 对于任意的常数a&gt;b&gt;0,有O(n^a+n^b)&#x3D;O(n^a)</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{align}
&(1)\ 对于任意的c>0,有O(f(n))=O(c\cdot f(n)) \\
&(2)\ 对于任意的常数a>b>0,有O(n^a+n^b)=O(n^a)
\end{align}</script></li>
</ul>
<ul>
<li><p>一种是后面不加行号，用的是<code>aligned</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">&amp;(1)\ 对于任意的c&gt;0,有O(f(n))&#x3D;O(c\cdot f(n)) \\</span><br><span class="line">&amp;(2)\ 对于任意的常数a&gt;b&gt;0,有O(n^a+n^b)&#x3D;O(n^a)</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{aligned}
&(1)\ 对于任意的c>0,有O(f(n))=O(c\cdot f(n)) \\
&(2)\ 对于任意的常数a>b>0,有O(n^a+n^b)=O(n^a)
\end{aligned}</script></li>
<li><p><strong>以上两种方式在typora Markdown编辑器中我还真没看出啥区别，但是上传到博客中确实没有了行号。</strong></p>
</li>
</ul>
<h2 id="LaTeX使用链接"><a href="#LaTeX使用链接" class="headerlink" title="LaTeX使用链接"></a>LaTeX使用链接</h2><p><a href="https://www.jianshu.com/p/4460692eece4" target="_blank" rel="noopener">https://www.jianshu.com/p/4460692eece4</a></p>
<p><a href="https://blog.csdn.net/qq_18150255/article/details/88040858" target="_blank" rel="noopener">https://blog.csdn.net/qq_18150255/article/details/88040858</a></p>
<p><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">https://www.jianshu.com/p/a0aa94ef8ab2</a></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解Intent</title>
    <url>/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　Intent是一个动作的完整描述，包含了产生组件、接收组件和传递数据信息。并且，Intent利用消息实现应用程序之间的交互机制，这种消息描述了应用中一次操作的动作、数据以及附加数据，系统通过该Intent的描述负责找到对应的组件，并将Intent传递给调用的组件，完成组件的调用。</p>
<h2 id="Intent属性"><a href="#Intent属性" class="headerlink" title="Intent属性"></a>Intent属性</h2><p>　　Intent由动作、数据、分类、类型、组件和扩展信息等内容组成，每个组成都由相应的属性进行表示，并提供设置和获取相应属性的方法。如下图所示：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423165652289.png" alt="image-20200423165652289" style="zoom: 67%;"></p>
<h3 id="Action属性"><a href="#Action属性" class="headerlink" title="Action属性"></a>Action属性</h3><p>　　Action属性用于描述Intent要完成的动作，对要执行的动作进行简单的描述。Intent类定义了一系列Action属性常量，用来标识一套标准动作，如ACTION_CALL（打电话）、ACTION_EDIT（编辑）等。</p>
<p>　　<font style="color:red;"><strong>注意：action只是一个普通的字符串，代表Intent要完成的一个抽象“动作”，而具体由哪个组件来完成，Intent并不负责！就是仅仅知道会有这个动作，谁来完成这个动作那就要交给Intent-filter来进行筛选了！根据我的理解，这个Intent应该就是起到一个中介的作用吧！</strong></font></p>
<p>以下是一些action属性常量：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423165910011.png" alt="image-20200423165910011"></p>
<h3 id="Data-Type属性"><a href="#Data-Type属性" class="headerlink" title="Data/Type属性"></a>Data/Type属性</h3><p>　　Data属性是执行动作的URI和MIME类型。通常用来向Action属性提供操作的数据，接受一个URI对象，URI的格式：scheme://host:post/path 参数依次为：协议头、主机、端口、路径；</p>
<p>　　Type通常用于指定Data所指定的Uri对应的MIME类型，比如能够显示图片数据的组件不应该用来播放音频文件，可以是自定义的MIME类型，只要符合abc/xyz格式的字符串就可以了。</p>
<p>Data常量如下：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423170056495.png" alt="image-20200423170056495"></p>
<p>Action和Data匹配使用，不同的Action由不同的Data数据指定</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423170147995.png" alt="image-20200423170147995"></p>
<h3 id="Category属性"><a href="#Category属性" class="headerlink" title="Category属性"></a>Category属性</h3><p>Category属性指明一个执行Action的分类。</p>
<font style="color:red;">**注意：同样是普通的字符串，Category用于为Action提供额外的附加类别信息，两者通常结合使用，一个Intent对象只能有一个Action，但是能有多个Category。**
</font>

<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423170350296.png" alt="image-20200423170350296"></p>
<h3 id="Component属性"><a href="#Component属性" class="headerlink" title="Component属性"></a>Component属性</h3><p>　　该属性用于指明Intent目标组件的类名称。通常Android会根据Intent包含的其他属性的信息，比如Action、 Data/Type、 Category 进行查找，最终找到一个与之匹配的目标组件。但是,如果指定了Component这个属性，Intent 则会直接根据组件名查找到相应的组件,而不再执行上述查找过程。<strong>指定Component属性后, Intent的其他属性都是可选的。</strong></p>
<h3 id="Extra属性"><a href="#Extra属性" class="headerlink" title="Extra属性"></a>Extra属性</h3><p>　　该属性用于添加附加信息，<strong>通常用于多个Action之间的数据交换</strong>，Extras属性是一个Bundle对象，通过键值对进行数据存储。下面介绍如何利用Intent在activity之间传递数据部分会详细介绍并举例实现。</p>
<h3 id="Flag属性"><a href="#Flag属性" class="headerlink" title="Flag属性"></a>Flag属性</h3><p>表示不同来源的标记，flag可以指导系统以何种方式启动一个activity、是否将启动的activity放在该应用的任务栈中等等。常用flags如下：</p>
<p>​    <strong>FLAG_ACTIVITY_NEW_TASK：</strong>设置这个标记位，是为 Activity 指定 “singleTask” 启动模式，它的作用和在清单文件中指定该启动模式的效果一样。</p>
<p>​    <strong>FLAG_ACTIVITY_SINGLE_TOP：</strong>设置这个标记位，是为 Activity 指定 “singleTop” 启动模式，它的作用和在清单文件中指定该启动模式的效果一样。</p>
<p>​    <strong>FLAG_ACTIVITY_CLEAR_TOP：</strong>具有此标记位的 Activity，在它启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈。</p>
<p>​    <strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：</strong>具有这个标记的 Activity 不会出现在历史 Activity 的列表中。它等同于在清单文件中指定 Activity 的属性android:excludeFromRecents=“true”</p>
<h2 id="Intent的类别"><a href="#Intent的类别" class="headerlink" title="Intent的类别"></a>Intent的类别</h2><p>　　根据Intent寻找目标组件时所采用的方式不同，可以将Intent分为两类：显示Intent和隐式Intent。</p>
<h3 id="显示Intent"><a href="#显示Intent" class="headerlink" title="显示Intent"></a>显示Intent</h3><p>　　显示Intent 通过直接指定组件来实现，常用方法有setComponent(、 setClassName0或setClass()，如下示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.open).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,UpdateUi<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：显式Intent直接用组件的名称定义目标组件，这种方式很直接。但是由于开发人员往往并不清楚别的应用程序的组件名称，因此，显式Intent更多用于在应用程序内部传递消息。比如在某应用程序内，一个Activity启动一个Service。</strong></p>
<h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p>　　隐式Intent,这种方式通过Intent Filter过滤实现,过滤时通常根据Action、Data和Category属性进行匹配查找。Android提供了两种生成Intent Filter的方式: 一种是通过IntentFilter类生成;另一种通过在配置文件AndroidManifest.xml中定义<intent-filter>元素生成。在AndroidManifest.xml配置文件中，Intent Filter以<intent filter>元素来指定。一个组件中可以有多个<intent filter>元素,每个<intent- filter>元素描述不同的能力。</intent-></intent></intent></intent-filter></p>
<p>　　<strong>注意：它更广泛地用于在不同应用程序之间传递消息，由于没有明确的目标组件名称，所以必须由Android系统帮助应用程序寻找与Intent请求意图最匹配的组件。</strong></p>
<p><strong>一个通过隐式Intent启动不同应用程序的activity的例子：</strong></p>
<ul>
<li><strong>首先要在一个应用程序中先设置好action</strong></li>
</ul>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423173522234.png" alt="image-20200423173522234"></p>
<ul>
<li><strong>然后在另一个应用程序里通过完整的action的name来启动。</strong></li>
</ul>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423173548963.png" alt="image-20200423173548963" style="zoom:150%;"> </p>
<ul>
<li><strong>启动时要将两个应用程序都打开。</strong></li>
</ul>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423173706410.png" alt="image-20200423173706410"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200423173712997.png" alt="image-20200423173712997"></p>
<ul>
<li><strong>在另一个activity上禁止启动的属性android:exported=”false”，则可以拒绝启动，并抛出异常，这时候可以捕获异常并弹出提示。</strong></li>
</ul>
<h2 id="利用Intent在Activity之间传递数据"><a href="#利用Intent在Activity之间传递数据" class="headerlink" title="利用Intent在Activity之间传递数据"></a>利用Intent在Activity之间传递数据</h2><h3 id="Intent传递简单数据"><a href="#Intent传递简单数据" class="headerlink" title="Intent传递简单数据"></a>Intent传递简单数据</h3><p>　　可以直接通过调用Intent的putExtra()方法存入数据，然后在通过getIntent()获得Intent后调用getXxxExtra获得 对应类型的数据；传递多个数据的话，可以使用Bundle对象作为容器，通过调用Bundle的putXxx先将数据存储到Bundle中，然后调用Intent的putExtras()方法将Bundle存入Intent中，然后调用getExtras()获得Bundle容器，最后调用其getXXX获取对应的数据！ </p>
<p><strong>举例如下：</strong></p>
<ul>
<li><p>传递单个数据：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813173857961.png" alt="image-20200813173857961"></p>
</li>
</ul>
<p>​       在另一个activity中先获取intent然后在获取数据</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813173946836.png" alt="image-20200813173946836"></p>
<ul>
<li><p>传递多个数据：</p>
<p>利用Bundle传递多个数据：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174050623.png" alt="image-20200813174050623"></p>
<p>在另一个activity中先获取Intent再获取Bundle</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174105999.png" alt="image-20200813174105999"></p>
</li>
</ul>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174119098.png" alt="image-20200813174119098" style="zoom:80%;"></p>
<h3 id="Intent传递数组"><a href="#Intent传递数组" class="headerlink" title="Intent传递数组"></a>Intent传递数组</h3><p>​    和以上传递数据类型差不多，直接举例如下：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174205607.png" alt="image-20200813174205607"></p>
<p>​    另一个activity里面获取，直接利用日志打印。</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174222600.png" alt="image-20200813174222600"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174226434.png" alt="image-20200813174226434"></p>
<h3 id="Intent传递集合"><a href="#Intent传递集合" class="headerlink" title="Intent传递集合"></a>Intent传递集合</h3><ul>
<li><p><strong>List:</strong></p>
<p>主activity写入集合</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174334748.png" alt="image-20200813174334748"></p>
<p>子activity获取并打印</p>
</li>
</ul>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174347484.png" alt="image-20200813174347484"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174353028.png" alt="image-20200813174353028"></p>
<h3 id="Intent传递对象"><a href="#Intent传递对象" class="headerlink" title="Intent传递对象"></a>Intent传递对象</h3><h4 id="Serializable实现"><a href="#Serializable实现" class="headerlink" title="Serializable实现:"></a>Serializable实现:</h4><p>​    ①业务Bean实现：Serializable接口,写上getter和setter方法</p>
<p>​    ②Intent通过调用putExtra(String name, Serializable value)传入对象实例 当然对象有多个的话多个的话,我们也可以先Bundle.putSerializable(x,x);</p>
<p>​    ③新Activity调用getSerializableExtra()方法获得对象实例: eg:Product pd = (Product) getIntent().getSerializableExtra(“Product”);</p>
<p>​    ④调用对象get方法获得相应参数。</p>
<p><strong>举例如下：</strong></p>
<p>​    首先，创建一个User类，实现Serializable接口,写上getter和setter方法。</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174524424.png" alt="image-20200813174524424"></p>
<p>然后在主activity中设置要传递的对象。</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174541278.png" alt="image-20200813174541278"></p>
<p>最后在子activity中获取该对象。</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174554777.png" alt="image-20200813174554777"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174603727.png" alt="image-20200813174603727" style="zoom:67%;"></p>
<h4 id="Parcelable实现"><a href="#Parcelable实现" class="headerlink" title="Parcelable实现:"></a>Parcelable实现:</h4><p>​    ①业务Bean继承Parcelable接口,重写writeToParcel方法,将你的对象序列化为一个Parcel对象;</p>
<p>​    ②重写describeContents方法，内容接口描述，默认返回0就可以</p>
<p>​    ③实例化静态内部对象CREATOR实现接口Parcelable.Creator</p>
<p>​    ④同样式通过Intent的putExtra()方法传入对象实例,当然多个对象的话,我们可以先 放到Bundle里Bundle.putParcelable(x,x),再Intent.putExtras()即可</p>
<p>​    <strong>说明：</strong>通过writeToParcel将你的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射 成你的对象。也可以将Parcel看成是一个流，通过writeToParcel把对象写到流里面， 在通过createFromParcel从流里读取对象，只不过这个过程需要你来实现，因此写的 顺序和读的顺序必须一致。</p>
<p><strong>举例如下：</strong></p>
<p>​    首先，修改User类，实现Parcelable接口，并添加以下方法：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174710754.png" alt="image-20200813174710754"></p>
<p>​    在主activity中设置对象，设置对象与Serializable设置一样：</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174745547.png" alt="image-20200813174745547"></p>
<p>​    在子activity中获取，注意获取方式不同</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174806920.png" alt="image-20200813174806920"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174813547.png" alt="image-20200813174813547" style="zoom:67%;"></p>
<h4 id="两种对象序列化方式的比较："><a href="#两种对象序列化方式的比较：" class="headerlink" title="两种对象序列化方式的比较："></a>两种对象序列化方式的比较：</h4><p>​    1）在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。</p>
<p>​    2）Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。</p>
<p>​    3）Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的 持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable。</p>
<p>​    4）Parcelable是android特有的序列化API，Serializable是java的序列化技术。</p>
<h3 id="Intent返回一个activity数据给另一个activity"><a href="#Intent返回一个activity数据给另一个activity" class="headerlink" title="Intent返回一个activity数据给另一个activity"></a>Intent返回一个activity数据给另一个activity</h3><p>​    获取另一个activity返回的数据时，启动另一个activity方法要改成startActivityForResult(i, 0);其中i是指的Intent，0是请求状态码，用来识别第二个activity传回的值</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174922356.png" alt="image-20200813174922356"></p>
<p>​    在第二个activity中用setResult(1,i);准备好要返回的数据，并通过finish()方法结束改activity，</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174935694.png" alt="image-20200813174935694"></p>
<p>​    然后返回到第一个activity中执行会调回函数onActivityResult</p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813174952752.png" alt="image-20200813174952752"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175040559.png" alt="image-20200813175040559" style="zoom:80%;"></p>
<h2 id="利用Intent调用系统组件"><a href="#利用Intent调用系统组件" class="headerlink" title="利用Intent调用系统组件"></a>利用Intent调用系统组件</h2><p>​        个人理解利用Intent调用系统组件实际上是利用了隐式Intent匹配组建的功能，通过匹配Action、data、category来打开对应的组件，如果有多个，则会出现选择列表来选择。</p>
<h3 id="打开系统联系人"><a href="#打开系统联系人" class="headerlink" title="打开系统联系人"></a>打开系统联系人</h3><p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175200241.png" alt="image-20200813175200241"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175204489.png" alt="image-20200813175204489"></p>
<h3 id="打电话"><a href="#打电话" class="headerlink" title="打电话"></a>打电话</h3><p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175247322.png" alt="image-20200813175247322"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175252983.png" alt="image-20200813175252983"></p>
<h3 id="发短信"><a href="#发短信" class="headerlink" title="发短信"></a>发短信</h3><p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175313735.png" alt="image-20200813175313735"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175317463.png" alt="image-20200813175317463"></p>
<h3 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h3><p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175333490.png" alt="image-20200813175333490"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175337613.png" alt="image-20200813175337613"></p>
<h3 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h3><p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175357358.png" alt="image-20200813175357358"></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Intent/image-20200813175407272.png" alt="image-20200813175407272"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Abbott的复仇</title>
    <url>/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=757" target="_blank" rel="noopener">UVA-816</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例输入：</span></span><br><span class="line"><span class="comment">3 1 N 3 3 </span></span><br><span class="line"><span class="comment">1 1 WL NR * </span></span><br><span class="line"><span class="comment">1 2 WLF NR ER * </span></span><br><span class="line"><span class="comment">1 3 NL ER * </span></span><br><span class="line"><span class="comment">2 1 SL WR NF * </span></span><br><span class="line"><span class="comment">2 2 SL WF ELF * </span></span><br><span class="line"><span class="comment">2 3 SFR EL * </span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">样例输出：</span></span><br><span class="line"><span class="comment">(3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>在做一道算法题目的时候，我认为真正地搞懂题目意思是非常重要的，题目搞不懂很可能会出现漏解的情况。我觉得从样例输入和输出出发，然后往题目中带，是比较好的理解方式。这道题目结合下图的理解如下：这个图我根据样例走了一遍，为防止混乱，先使用红色，当节点重复了再用蓝色，然后再用绿色，最终走到终点。</p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200415143834740.png" alt="image-20200415143834740" style="zoom:80%;"></p>
<p>​            首先看样例输入的第一行，一个起点坐标(3,1)<strong>代表第三行第一列</strong>，一个离开起点时的位置N<strong>代表离开起点时朝向上</strong>，一个终点坐标(3,3)<strong>代表第三行第三列</strong>。一开始的时候我是有点疑问的：为什么上图的最下面有两个点表示起点和终点和样例中的不太一样啊，可后来想了想，样例输出可以有很多的，题目中的图只代表了一种情况，<strong>所以不用管多余的点</strong>。</p>
<p>​            然后看每一个坐标，都有进入坐标的方向，即NEWS，分表表示上、右、左、下，LFR分别表示进入该点可以向左、直走、向右走。结合样例比如1 1 WL NR<code>*</code>，对应图中的(1,1)坐标点，表示当进入(1,1)时的方向，如果是W，即向左的话，那么此时你只能左转；如果进入(1,1)朝向向上的话，此时只能右转，输入<code>*</code>代表此节点的输入结束，接着读取下一行，然后输入0代表整个输入结束。</p>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><p>​            说是研究对象可能有点过了，这里我指的是在算法解决问题的过程中所定义的几个重要的变量，下面针对我认为很重要的变量解释一波。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、Node结构体：这是一个三元组，用来表示位于(r,c)位置，dir表示方向朝向</span></span><br><span class="line"><span class="comment">2、has_edge[r][c][dir][turn]数组：这个四维数组表示当前状态是(r,c,dir)，是否可以朝turn转向。初始化为0，设为1表示可以转向。</span></span><br><span class="line"><span class="comment">3、d[r][c][dir]数组：该数组表示记录当前状态的节点与初始化状态的节点的距离。该数组初始化为-1。并且起点为-1，与题目意思切合，起点的下一个位置才是初始状态，所以下一个位置为0，所以也可以认为d数组是用来记录移动次数的，每移动一个节点值加一。方便打印的时候从跟节点回溯。</span></span><br><span class="line"><span class="comment">4、p[r][c][dir]数组：该数组表示了(r,c,dir)在BFS树中的父节点，在BFS树中除了起点外，每个节点都有唯一一个父节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>对用来解决问题的函数方法先说明一下。</p>
<ul>
<li><p>read_case();该方法是将所有的输入转换到has_edge数组中，表示此状态下节点所允许的转向。结合上图的BFS树理解也就是在该节点状态下有几个分支可以走。</p>
</li>
<li><p>dir_id();将NESW四个方向转换为0~3整数，方便在数组中当下标使用。</p>
</li>
<li><p>turn_id();将FLR三个转向转换为0~2整数，方便在数组中当下标使用。</p>
</li>
<li><p>walk();这个函数极为巧妙，用来获取转向后的下一个状态。根据FLR三种不同的转向，如果转向为L，即向左转，那么就顺时针加三，比如此时朝向为S，转向为L，那么在现实中我们很容易想到就是E，但是利用代码的话就是(dir+3)%4，这里为什么要用加？这是因为用加的话取余就可以再次从头开始循环NESW，但是逻辑上应该是逆时针减一的;如果转向为R，即向右转，那么就顺时针加一；如果转向为F，那么dir方向不变。</p>
<p>可以画一下图，一下子就理解了，见下图。</p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200417212146564.png" alt="image-20200417212146564" style="zoom:50%;"></p>
</li>
<li><p>solve();利用BFS方法模拟走路，分别查看FLR三个转向能否走，也就是层次遍历的核心了。然后每走一步就在上面定义的数组中更新一下状态，并把当前满足条件的分支加入到队列中。思路见下图。</p>
</li>
</ul>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200417214024977.png" alt="image-20200417214024977" style="zoom: 67%;"></p>
<p>最终可得到类似下图的BFS层次树</p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200415183218122.png" alt="image-20200415183218122"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>​            下面就将详细的解题思路注释在代码中，有时候看代码比看文字理解起来更容易。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> r,c,dir;<span class="comment">//站在(r,c)点，面朝方向dir(0~3)分别表示N,E,S,W</span></span><br><span class="line">	Node(<span class="keyword">int</span> r=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>,<span class="keyword">int</span> dir=<span class="number">0</span>):r(r),c(c),dir(dir)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* dirs=<span class="string">"NESW"</span>;<span class="comment">//上0 右1 下2 左3 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* turns=<span class="string">"FLR"</span>;<span class="comment">//直行0 左转1 右转2</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//这两个数组用来根据朝向设置移动步数，0~3下标分别对应NESW </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> has_edge[maxn][maxn][<span class="number">4</span>][<span class="number">3</span>];<span class="comment">//节点可能的转向 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn][<span class="number">4</span>];<span class="comment">//记录此时与起点的距离 </span></span><br><span class="line">Node p[maxn][maxn][<span class="number">4</span>];<span class="comment">//记录此节点的直接父节点</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义起点坐标、离开起点时方向、初始状态坐标和终点坐标 </span></span><br><span class="line"><span class="keyword">int</span> r0,c0,dir,r1,c1,r2,c2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符NESW，方位的顺时针转为从0~3的整数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_id</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strchr</span>(dirs,c)-dirs;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将转向数组转为0~2的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">turn_id</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strchr</span>(turns,c)-turns;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入函数，初始化起点终点和每一个坐标的专线 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_case</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ch用来读取离开初始位置的方向,s用来读取每个节点可能的转向 </span></span><br><span class="line">	<span class="keyword">char</span> ch[maxn],s[maxn];</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%s%d%d"</span>,&amp;r0,&amp;c0,&amp;ch,&amp;r2,&amp;c2)!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	dir=dir_id(ch[<span class="number">0</span>]);</span><br><span class="line">	r1=r0+dr[dir];<span class="comment">//这个是离开起点的第一个位置，即初始状态 </span></span><br><span class="line">	c1=c0+dc[dir];</span><br><span class="line">	<span class="keyword">int</span> r,c;</span><br><span class="line">	<span class="built_in">memset</span>(has_edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(has_edge));	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> d=dir_id(s[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> t=turn_id(s[i]);</span><br><span class="line">				has_edge[r][c][d][t]=<span class="number">1</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据转向更新节点 </span></span><br><span class="line"><span class="function">Node <span class="title">walk</span><span class="params">(Node u,<span class="keyword">int</span> <span class="built_in">turn</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dir=u.dir;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">1</span>) dir=(dir+<span class="number">3</span>)%<span class="number">4</span>;<span class="comment">//如果转向为L，更新转向为顺时针数三个位置 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">2</span>) dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;<span class="comment">//如果转向为R，更新转向为顺时针数一个位置 </span></span><br><span class="line">	<span class="keyword">return</span> Node(u.r+dr[dir],u.c+dc[dir],dir); </span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">//判断数组是否出界</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> r&gt;=<span class="number">1</span>&amp;&amp;r&lt;=<span class="number">9</span>&amp;&amp;c&gt;=<span class="number">1</span>&amp;&amp;c&lt;=<span class="number">9</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//打印路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ans</span><span class="params">(Node u)</span></span>&#123;</span><br><span class="line">	<span class="comment">//从终点向起点添加到vector中，然后反向遍历输出路径 </span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		nodes.push_back(u); </span><br><span class="line">		<span class="keyword">if</span>(d[u.r][u.c][u.dir]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//此时跳出循环，为初始状态节点，但不是起点 </span></span><br><span class="line">		u=p[u.r][u.c][u.dir];<span class="comment">//把这个节点的父节点找出来，再加入到向量中 </span></span><br><span class="line">	&#125;</span><br><span class="line">	nodes.push_back(Node(r0,c0,dir));<span class="comment">//记得把起点加入到vector中</span></span><br><span class="line">	<span class="comment">//最后反向遍历，每十个为一行输出路径</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span>=nodes.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">end</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d,%d) "</span>,nodes[i].r,nodes[i].c);</span><br><span class="line">		<span class="keyword">if</span>(++cnt%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>,nodes[<span class="number">0</span>].r,nodes[<span class="number">0</span>].c);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS层次数模拟走路 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="function">Node <span class="title">u</span><span class="params">(r1,c1,dir)</span></span>;<span class="comment">//走了一步之后的初始状态</span></span><br><span class="line">	d[u.r][u.c][u.dir]=<span class="number">0</span>;<span class="comment">//每走一步加一 </span></span><br><span class="line">	q.push(u);<span class="comment">//在这里先把初始状态放入队列，然后在while中操作 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		Node u=q.front();q.pop();</span><br><span class="line">		<span class="keyword">if</span>(u.r==r2&amp;&amp;u.c==c2)&#123;<span class="comment">//如果走到终点 </span></span><br><span class="line">			print_ans(u);<span class="comment">//打印路径 </span></span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//跳出solve函数 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不是终点的话就继续走我认为从这个for循环开始体现BFS的核心思想了 </span></span><br><span class="line">		<span class="comment">//循环三次0~2，表示能否转向FLR,在BFS层次树上体现的是遍历三个分支</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			Node v=walk(u,i);</span><br><span class="line">			<span class="keyword">if</span>(has_edge[u.r][u.c][u.dir][i]&amp;&amp;<span class="comment">//这里要看当前节点是否可以分支转向！！！ </span></span><br><span class="line">				inside(v.r,v.c)&amp;&amp;</span><br><span class="line">				d[v.r][v.c][v.dir]&lt;<span class="number">0</span>)&#123;<span class="comment">//这里小于0的意思是之前走过的路不能再走了，再走就闭合了 </span></span><br><span class="line">				d[v.r][v.c][v.dir]=d[u.r][u.c][u.dir]+<span class="number">1</span>;<span class="comment">//更新层次，在上一层的基础上加一，即到起点的距离加一 </span></span><br><span class="line">				p[v.r][v.c][v.dir]=u;<span class="comment">//把u作为v的直接父节点，v是u的下一步之后的要想清楚 </span></span><br><span class="line">				q.push(v);<span class="comment">//把下一步的节点放入队列，方便下一轮的BFS遍历 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//当没有走到终点的情况下队列为空了，就说明可能无解！ </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No solution possible\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(read_case())&#123;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下：</strong></p>
<p><img src="/2020/04/15/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/image-20200417224912902.png" alt="image-20200417224912902" style="zoom:67%;"></p>
<h2 id="第二次代码实现"><a href="#第二次代码实现" class="headerlink" title="第二次代码实现"></a>第二次代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> r,c,dir;</span><br><span class="line">	Node(<span class="keyword">int</span> r=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>,<span class="keyword">int</span> dir=<span class="number">0</span>):r(r),c(c),dir(dir)&#123;&#125;<span class="comment">//赋初值，不然声明会报错 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* dirs=<span class="string">"NESW"</span>;<span class="comment">//定义方向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* turns=<span class="string">"FLR"</span>;<span class="comment">//定义转向 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dr[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//定义纵向步长 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dc[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//定义横向步长</span></span><br><span class="line"><span class="keyword">int</span> has_edge[maxn][maxn][<span class="number">4</span>][<span class="number">3</span>];<span class="comment">//定义方向状态数组 </span></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn][<span class="number">4</span>];<span class="comment">//定义此节点在层次树中的层数，也可以说是节点距离起点的距离</span></span><br><span class="line">Node p[maxn][maxn][<span class="number">4</span>];<span class="comment">//记录此节点的上一个节点即直接父节点 </span></span><br><span class="line"><span class="comment">//起点、离开起点时的方向、初始状态、终点</span></span><br><span class="line"><span class="keyword">int</span> r0,c0,dir,r1,c1,r2,c2; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方向转ID </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dirs_id</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strchr</span>(dirs,ch)-dirs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转向转ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">turns_id</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strchr</span>(turns,ch)-turns;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//读取输入 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_case</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch[maxn],s[maxn];</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%s%d%d"</span>,&amp;r0,&amp;c0,ch,&amp;r2,&amp;c2)!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	dir=dirs_id(ch[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	r1=r0+dr[dir];<span class="comment">//设置初始状态点 </span></span><br><span class="line">	c1=c0+dc[dir];</span><br><span class="line">	<span class="comment">//依次读取每个节点的方向状态，用数组保存</span></span><br><span class="line">	<span class="keyword">int</span> r,c;</span><br><span class="line">	<span class="comment">//每次读入前先将方向状态数组初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(has_edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(has_edge)); </span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> d=dirs_id(s[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">				has_edge[r][c][d][turns_id(s[i])]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印输出最短路径 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ans</span><span class="params">(Node u)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		nodes.push_back(u);</span><br><span class="line">		<span class="keyword">if</span>(d[u.r][u.c][u.dir]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> 		u=p[u.r][u.c][u.dir];		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//然后把起点加上</span></span><br><span class="line">	nodes.push_back(Node(r0,c0,dir));</span><br><span class="line">	<span class="comment">//倒序输出</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span>=nodes.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">end</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d,%d) "</span>,nodes[i].r,nodes[i].c);</span><br><span class="line">		<span class="keyword">if</span>(++cnt%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>,nodes[<span class="number">0</span>].r,nodes[<span class="number">0</span>].c);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据转向移动一步 </span></span><br><span class="line"><span class="function">Node <span class="title">walk</span><span class="params">(Node u,<span class="keyword">int</span> <span class="built_in">turn</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dir=u.dir;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">1</span>) dir=(dir+<span class="number">3</span>)%<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">2</span>) dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">return</span> Node(u.r+dr[dir],u.c+dc[dir],dir);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//判断是否出界 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> r&gt;=<span class="number">0</span>&amp;&amp;r&lt;=<span class="number">9</span>&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;=<span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造bfs层次树 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="function">Node <span class="title">u</span><span class="params">(r1,c1,dir)</span></span>;</span><br><span class="line">	d[u.r][u.c][u.dir]=<span class="number">0</span>;</span><br><span class="line">	q.push(u);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		Node u=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span>(u.r==r2&amp;&amp;u.c==c2)&#123;<span class="comment">//第一次到达终点直接打印输出 </span></span><br><span class="line">			print_ans(u);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">//分别看三个转向能否走通 </span></span><br><span class="line">			Node v=walk(u,i);</span><br><span class="line">			<span class="keyword">if</span>(has_edge[u.r][u.c][u.dir][i]&amp;&amp;<span class="comment">//看此节点状态是否允许转向</span></span><br><span class="line">				inside(v.r,v.c)&amp;&amp;<span class="comment">//看是否出界</span></span><br><span class="line">				d[v.r][v.c][v.dir]&lt;<span class="number">0</span><span class="comment">//判断是否走过此节点，走过就成环路了 </span></span><br><span class="line">				)&#123;<span class="comment">//原来如此，妈的这里竟然忘记括号了 </span></span><br><span class="line">					d[v.r][v.c][v.dir]=d[u.r][u.c][u.dir]+<span class="number">1</span>;<span class="comment">//在层次树中的层次再上一个节点的基础上加一</span></span><br><span class="line">					p[v.r][v.c][v.dir]=u; <span class="comment">//这里一定要记住是把当前节点作为下一个节点的父节点啊 </span></span><br><span class="line">					q.push(v);<span class="comment">//如果走了一步，就加入到队列中 </span></span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果走完了还没有到终点，可能无解</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No solution!\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(read_case())&#123;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法入门</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解自动构建工具Gradle</title>
    <url>/2020/04/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/</url>
    <content><![CDATA[<h2 id="Gradle概述"><a href="#Gradle概述" class="headerlink" title="Gradle概述"></a>Gradle概述</h2><p>　　Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。Gradle就是工程的管理，帮我们做了依赖、打包、部署、发布、各种渠道的差异管理等工作。</p>
<h2 id="Gradle优势"><a href="#Gradle优势" class="headerlink" title="Gradle优势"></a>Gradle优势</h2><ul>
<li><p>一款最新的，功能最强大的构建工具，用它逼格更高。</p>
</li>
<li><p>使用程序代替传统的XML配置，项目构建更灵活。</p>
</li>
<li><p>丰富的第三方插件，让你随心所欲使用。</p>
</li>
<li><p>Maven、Ant能做的，Gradle都能做，但是Gradle能做的，Maven、Ant不一定能做。</p>
</li>
</ul>
<h2 id="Gradle插件"><a href="#Gradle插件" class="headerlink" title="Gradle插件"></a>Gradle插件</h2><p>　　AndroidStudio Gradle Plugin，也就是AndroidStudio用于开发Android项目的gradle插件。Gradle插件会有版本号，每个版本号又对应有一个或一些 Gradle发行版本（一般是限定一个最低版本），也就是我们常见的类似gradle-4.1-all.zip这种东西；如果这两个版本对应不上了，那你的工程构建的时候就会报错。</p>
<p>　　Android Gradle Plugin又会跟 Android SDK BuildTool有关联（版本有对应的关系），因为它还承接着Android Studio里的编译相关的功能，这也是我们要在项目的 local.properties 文件里写明Android SDK路径、在build.gradle 里注明 buildToolsVersion 的原因。Android Gradle Plugin 本质上就是 一个AS的插件，它一边调用 Gradle本身的代码和批处理工具来构建项目，一边调用Android SDK的编译、打包功能，从而让我们能够顺畅地在AS上进行开发。</p>
<p>　　<strong>另外，Gradle插件和Gradle不是一个东西。</strong></p>
<h2 id="Gradle相关文件分析"><a href="#Gradle相关文件分析" class="headerlink" title="Gradle相关文件分析"></a>Gradle相关文件分析</h2><h3 id="工程目录下的build-gradle文件"><a href="#工程目录下的build-gradle文件" class="headerlink" title="工程目录下的build.gradle文件"></a>工程目录下的build.gradle文件</h3><p><strong>主要作用：对Gradle插件进行配置</strong></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/image-20200423154529906.png" alt="image-20200423154529906" style="zoom:80%;"></p>
<p>　　首先，两处repositories的闭包中都声明了jcenter()这行配置，它是一个代码托管仓库，很多Android 开源项目都会选择将代码托管到jcenter上，声明了这行配置之后，我们就可以在项目中轻松引用任何jcenter上的开源项目了。</p>
<p>　　接下来，dependencies 闭包中使用classpath声明了一个Gradle插件因为Gradle并不是专门为构建Android项目而开发的，Java、 C++等很多种项目都可以使用Gradle来构建。因此如果我们要想使用它来构建Android项目,则需要声明com.android.tools . build:gradle:2.３.１这个插件。其中，最后面的部分是插件的版本号。</p>
<h3 id="app目录下的build-gradle文件"><a href="#app目录下的build-gradle文件" class="headerlink" title="app目录下的build.gradle文件"></a>app目录下的build.gradle文件</h3><p><strong>主要作用：app模块的gradle构建脚本，一般用来管理app包名、版本的以及添加和修改依赖库。</strong></p>
<p><img src="/2020/04/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/image-20200423154740294.png" alt="image-20200423154740294" style="zoom: 67%;"></p>
<p>　　首先，第一行应用了一个插件，有两种值可以选 com.android.application(表示这是一个应用程序模块) 和 com.android.library(表示这是一个库模块)。应用程序模块和库模块最大的区别:前者可以直接运行，后者只能作为代码库依附于别的应用程序模块来运行。</p>
<p>　　接下来是一个大的android闭包，在这个闭包中我们可以配置项目构建的各种属性。</p>
<p><strong>compileSdkVersio：</strong>用于指定项目的编译版本,这里指定成24表示使用Android 7.0系统的SDK编译。</p>
<p><strong>buildToolsVersion：</strong>用于指定项目构建工具的版本，如果有更新的版本时，Android Studio会进行提示。</p>
<p>　　然后，在android闭包中又嵌套了一个defaultConfig闭包, defaultConfig 闭包中可以对项目的更多细节进行配置。其中，</p>
<p><strong>applicationId：</strong>用于指定项目的包名，前面我们在创建项目的时候其实已经指定过包名了,如果想在后面对其进行修改,那么就是在这里修改的。</p>
<p><strong>minSdkVersion：</strong>用于指定项目最低兼容的Android 系统版本，指定成15表示最低兼容到Android 4.0系统。</p>
<p><strong>targetSdkVersion：</strong>指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特性。比如说Android 6.0系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能，而如果你将targetSdkVersion 指定成22,那么就说明你的程序最高只在Android5.1系统上做过充分的测试，Android 6.0系统中引入的新功能自然就不会启用了。</p>
<p><strong>versionCode：</strong>用于指定项目的版本号，</p>
<p><strong>versionName：</strong>用于指定项目的版本名，这两个属性在生成安装文件的时候非常重要。</p>
<p>　　buildTypes 闭包中用于指定生成安装文件的相关配置，通常只会有两个子闭包，一个是debug, 一个是release。debug闭包用于指定生成测试版安装文件的配置, release闭包用于指定生成正式版安装文件的配置。另外，debug闭包是可以忽略不写的，因此可以看到上面的代码中就只有一个release 闭包。</p>
<p><strong>minifyEnabled：</strong>用于指定是否对项目的代码进行混淆，true 表示混淆，false 表示不混淆。</p>
<p><strong>proguardFiles：</strong>用于指定混淆时使用的规则文件，这里指定了两个文件，第一个proguard-android. txt是在Android SDK目录下的，里面是所有项目通用的混淆规则，第二个proguard- rules. pro是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则。需要注意的是,通过Android Studio直接运行项目生成的都是测试版安装文件。</p>
<p>　　dependencies闭包的功能非常强大,它可以指定当前项目所有的依赖关系。通常Android Studio项目一共有3种依赖方式:<strong>本地依赖、库依赖和远程依赖</strong>。本地依赖可以对本地的Jar包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖则可以对jcenter库上的开源项目添加依赖关系。观察一下dependencies 闭包中的配置，</p>
<p>第一行的compile fileTree 就是一个本地依赖声明，它表示将libs 目录下所有.jar后缀的文件都添加到项目的构建路径当中。</p>
<p>第二行的compile 则是远程依赖声明, com. android. support:appcompat -v7:24.2.1就是一个标准的远程依赖库格式,其中com. android. support是域名部分,用于和其他公司的库做区分; appcompat-v7是组名称,用于和同一个公司中不同的库做区分; 24.2.1 是版本号，用于和同一个库不同的版本做区分。加上这句声明后，<strong>Gradle在构建项目时会首先检查一下本地是否已经有这个库的缓存，如果没有的话则会去自动联网下载</strong>，<strong>然后再添加到项目的构建路径当中</strong>。至于库依赖声明这里没有用到，它的基本格式是compile project 后面加上要依赖的库名称，比如说有一个库模块的名字叫helper,那么添加这个库的依赖关系只需要加入compile project( ‘ :helper’ )这句声明即可。</p>
<h3 id="gradle-wrapper-properties文件"><a href="#gradle-wrapper-properties文件" class="headerlink" title="gradle-wrapper.properties文件"></a>gradle-wrapper.properties文件</h3><p><strong>主要作用：对Gradle进行全局配置,在这里配置的属性将会影响到项目中所有的gradle编译脚本。</strong></p>
<p><strong>Grale配置的意义在于：在项目创建或者编译的时候如何查找Gradle的位置和使用什么版本的Gradle。</strong></p>
<p>​    <strong>zipStoreBase和zipStorePath</strong>组合在一起，是下载的gradle-4.4-all.zip所存放的位置。</p>
<p>​    <strong>zipStorePath**</strong>：**是zipStoreBase指定的目录下的子目录。</p>
<p>​    <strong>distributionBase**</strong>和distributionPath**组合在一起，是解压gradle-4.4-all.zip之后的文件的存放位置。</p>
<p>​    <strong>distributionPath**</strong>：**是distributionBase指定的目录下的子目录。</p>
<p>​    <strong>distributionUrl**</strong>：**Gradle下载地址</p>
<p><strong>Gradle查找方法之一：先到本机的缓存目录中寻找，找到则使用，找不到则到Gradle下载地址去下载。下载完成会将保存一份到本机的缓存目录。</strong></p>
<h3 id="local-properties文件"><a href="#local-properties文件" class="headerlink" title="local.properties文件"></a>local.properties文件</h3><p><strong>主要作用：在Android Studio中是用来配置SDK目录的,也可以在文件中配置一些本地化的变量。</strong></p>
<p>前面介绍Gradle插件的时候提到，Android Gradle Plugin会跟 Android SDK BuildTool有关联（版本有对应的关系），因为它还承接着Android Studio里的编译相关的功能，所以要在项目的 local.properties 文件里写明Android SDK的路径。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构---绪论</title>
    <url>/2020/04/16/%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p>对特定问题求解步骤的一种描述。</p>
<h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><ul>
<li>有穷性：算法必须总是执行有穷步之后结束且每一步都在有穷时间内完成</li>
<li>确定性：每一条指令必须有确切的含义</li>
<li>可行性：算法是可行的</li>
<li>输入：有零个或多个输入</li>
<li>输出：有一个或多个输出</li>
</ul>
<h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><p>　　算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>　　算法执行时间的变化趋势可以表示为输入规模的一个函数，称作该算法的时间复杂度，记作$T(n)$。从保守估计的角度出发，$T(n)$就是所有输入中执行时间最长的。</p>
<h3 id="渐进复杂度"><a href="#渐进复杂度" class="headerlink" title="渐进复杂度"></a>渐进复杂度</h3><p>　　为什么要引出渐进复杂度？是因为在评价算法运行效率的时候，我们往往是可以忽略其处理小规模问题时的能力差异，转而去关注其在处理更大规模问题时的表现。因为小规模问题处理起来时间本来就少，故此时不同算法的实际效率差异并不明显；而在处理更大规模的问题的时候，效率的些许差异都将对实际执行效果产生巨大的影响。</p>
<p>　　所谓的的渐进分析就是着眼长远、更为注重时间复杂度的总体变化趋势和增长速度的策略和方法。</p>
<p>　　为了更好的度量和评价时间复杂度的渐进增长速度，引入三个符号：$O,\Omega,\Theta$来分别渐进分析一个算法的最好、最坏和平均情况。</p>
<h4 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h4><p>　　首先这是一个函数，函数就可以输入进去变量，然后输出经过函数处理过后的值，先给出下面的公式，然后再做推导。</p>
<script type="math/tex; mode=display">
T(n)=O(f(n)) \tag{1}</script><p>　　<strong>推导:</strong>具体地，若存在正的常数c和函数f(n)，使得对任何$n&gt;&gt;2$（n远大于2）都有</p>
<script type="math/tex; mode=display">
T(n)\leq c\cdot f(n) \tag{2}</script><p>则可认为在n足够大之后，f(n)给出了T(n)增长速度的一个渐进上界，也就是公式(1)。<strong>上面式子中的f(n)函数指的是算法中基本操作重复执行的次数是问题规模n的某个函数，也就是说f(n)代表了这个算法中所有语句执行次数的和。</strong></p>
<p>　　通俗的理解上面的两个式子，就得先知道O到底干了什么，首先它是一个函数，前面说了函数的话是会在里面执行一些操作，而<strong>O进行的操作就是把输入里面的变量做了这两种变化：1、所有的正的常数项系数可以忽略并等同于一；2、多项式中只保留最高次项。</strong>那就好理解公式(1)中为什么用等于号了，因为经过这两步变换后，输入O的变量自然会小于等于$c\cdot f(n)$,都小于等于的话就可认为$T(n)=O(f(n))$了。根据上面的定义，就可以得出大$O$的如下两个性质了</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(1)\ 对于任意的c>0,有O(f(n))=O(c\cdot f(n)) \\
&(2)\ 对于任意的常数a>b>0,有O(n^a+n^b)=O(n^a)
\end{aligned}</script><p>　　<strong>可以看出，大$O$记号的这些性质很好地体现了对函数总体渐进增长趋势的关注和刻画。</strong></p>
<p>　　一个例子，在冒泡排序算法中，最差的输入情况需要执行的基本操作不会超过$2(n-1)^2$次，表示为该算法的时间复杂度为</p>
<script type="math/tex; mode=display">
T(n)=O(2(n-1)^2)</script><p>根据大$O$记号的性质，就可以进一步简化和整理为</p>
<script type="math/tex; mode=display">
T(n)=O(2n^2-4n+2)=O(2n^2)=O(n^2)</script><h4 id="大-Omega-记号"><a href="#大-Omega-记号" class="headerlink" title="大$\Omega$记号"></a>大$\Omega$记号</h4><p>　　为了对算法的复杂度最好情况做出估计，需要借助另一个记号。如果存在正的常数c和函数 g(n)，使得对于任何n &gt;&gt; 2都有 </p>
<script type="math/tex; mode=display">
T(n)\geq c \cdot g(n)</script><p>就可以认为，在n足够大之后，g(n)给出了T(n)的一个渐进下界。此时，我们记之为</p>
<script type="math/tex; mode=display">
T(n)=\Omega(g(n))</script><p>与大O记号恰好相反，大$\Omega$记号是对算法执行效率的乐观估计——对于规模为n的任意输入，算法的运行时间都不低于$\Omega$(g(n))。比如， 即便在最好情况下，起泡排序也至少需要T(n) = $\Omega$(n)的计算时间。</p>
<h4 id="大-Theta-记号"><a href="#大-Theta-记号" class="headerlink" title="大$\Theta$记号"></a>大$\Theta$记号</h4><p>　　借助大O记号、大$\Omega$记号，可以对算法的时间复杂度作出定量的界定，亦即，从渐进的趋势看，T(n)介于$\Omega$(g(n))与O(f(n))之间。若恰巧出现g(n) = f(n)的情况，则可以使用另一记号来表示。</p>
<p>　　如果存在正的常数c1 &lt; c2和函数h(n)，使得对于任何n &gt;&gt; 2都有 </p>
<script type="math/tex; mode=display">
c_1\cdot h(n) \leq T(n) \leq c_2\cdot h(n)</script><p>就可以认为在n足够大之后，h(n)给出了T(n)的一个确界。此时，我们记之为： </p>
<script type="math/tex; mode=display">
T(n)=\Theta(h(n))</script><p>它是对算法复杂度的准确估计——对于规模为n的任何输入，算法的运行时间T(n)都与$\Theta$(h(n))同阶。</p>
<p><img src="/2020/04/16/%E7%BB%AA%E8%AE%BA/image-20200416182804052.png" alt="image-20200416182804052" style="zoom: 80%;"></p>
<h2 id="常用算法复杂度"><a href="#常用算法复杂度" class="headerlink" title="常用算法复杂度"></a>常用算法复杂度</h2><p>　　由于算法的时间复杂度考虑的只是对于问题规模n的增长率，则在难以精确计算基本操作执行次数(或语句频度)的情况下，只需求出它关于n的增长率或阶即可。以下学习记录了几种常见数量级的时间复杂度。</p>
<h3 id="常数O-1"><a href="#常数O-1" class="headerlink" title="常数O(1)"></a>常数O(1)</h3><p>　　一般地，仅含<strong>一次或常数次</strong>基本操作的算法。此类算法 <strong>通常不含循环、分支、子程序调用</strong>等，但也不能仅凭语法结构的表面形式一概而论。</p>
<h3 id="对数O-logn"><a href="#对数O-logn" class="headerlink" title="对数O(logn)"></a>对数O(logn)</h3><p>　　该复杂度最城建的就是二分法查找，每次数据规模n都会减半，学过高中数学可以知道，对数是用来求次数的，这应该有个2，在界定渐进复杂度的时候具体取值无所谓，<strong>这里logn可以看做是执行的次数，即减半了多少次。</strong></p>
<h3 id="线性O-n"><a href="#线性O-n" class="headerlink" title="线性O(n)"></a>线性O(n)</h3><p>　　该复杂度即线性时间复杂度，可以认为在一个for循环内完成的时间复杂度。</p>
<h3 id="多项式O-polynomial-n"><a href="#多项式O-polynomial-n" class="headerlink" title="多项式O(polynomial(n))"></a>多项式O(polynomial(n))</h3><p>　　若运行时间可以表示和度量为T(n) = O(f(n))的形式，而且f(x)为多项式，则对应的算法 称作“多项式时间复杂度算法”。</p>
<h3 id="指数O-2-n"><a href="#指数O-2-n" class="headerlink" title="指数O($2^n$)"></a>指数O($2^n$)</h3><p> 　　当问题规模较大后，指数复杂度算法 的实际效率将急剧下降，计算时间之长很快就会达到令人难以忍受的地步。</p>
<h3 id="复杂度层次"><a href="#复杂度层次" class="headerlink" title="复杂度层次"></a>复杂度层次</h3><p><img src="/2020/04/16/%E7%BB%AA%E8%AE%BA/image-20200421213536050.png" alt="image-20200421213536050"></p>
<h2 id="算法复杂度分析方法"><a href="#算法复杂度分析方法" class="headerlink" title="算法复杂度分析方法"></a>算法复杂度分析方法</h2><h3 id="观察循环层数"><a href="#观察循环层数" class="headerlink" title="观察循环层数"></a>观察循环层数</h3><h4 id="三重循环"><a href="#三重循环" class="headerlink" title="三重循环"></a>三重循环</h4><p>看下面的矩阵乘法代码，可以看到一共有三个for循环，那么里面的那条语句的执行次数也就是$n^3$。如果n的取值为200时，大约就是要执行$8\times10^6$次基本操作。<font style="color:red;"><strong>比赛中一般执行次数在$10^7$内为最佳。</strong></font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix_Mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                c[i][j]=a[i][k]*b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带有隐性循环的strlen"><a href="#带有隐性循环的strlen" class="headerlink" title="带有隐性循环的strlen"></a>带有隐性循环的strlen</h4><p>下面的代码中，很容易看成只有一个for循环，然后判定时间复杂度为O(n)，其实不然，因为strlen(ch)函数实际上需要走遍字符串中的每个字符。所以其复杂度实际上应该为O(n^2)。<strong>所以在以后使用strlen的时候，最好是将其放在循环外面。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cout_A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(ch);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i]==<span class="string">'A'</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="确定搜索状态数"><a href="#确定搜索状态数" class="headerlink" title="确定搜索状态数"></a>确定搜索状态数</h3><h4 id="n-n-的排列"><a href="#n-n-的排列" class="headerlink" title="$n^n$的排列"></a>$n^n$的排列</h4><p>　　相比于循环，搜索的时间复杂度并不那么直观；但是只要将每个状态作为一个单位来分析，再乘以每个单位对应的时间复杂度，对应的时间复杂度分析也就不难了。简单地说，<strong>搜索的时间复杂度=每个状态对应的时间复杂度x状态数</strong>（如果不一样时，视情况分类处理或按最坏情况计算）。只要理解了这段话中的状态基本上就懂了为啥下面的这个代码的复杂度是O($n<em>n^n$)。这个状态也就是指的可能的结果有多少中，在下面这个题目中也就是res数组有多少种情况，从depth=1开始，也就是说数组的每一位都可能是从1~n,所以就有$n^n$个可能的状态(这个和高中的排列差不多)，<em>*但是前面要乘以n就比较难理解了,这个意思就是指的每一个状态的时间复杂度，可以这么想，我定下了一个状态是数组的值全部为1，那么就要循环遍历执行复杂度为n的赋值操作啊！</em></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==n+<span class="number">1</span>) &#123;update_answer(); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        rec[depth]=i;<span class="comment">//赋值从而确定每个状态</span></span><br><span class="line">        dfs(depth+<span class="number">1</span>);</span><br><span class="line">        rec[depth]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不能有重复的排列"><a href="#不能有重复的排列" class="headerlink" title="不能有重复的排列"></a>不能有重复的排列</h4><p>　　在上面的分析基础上添加限制条件，不允许数组中的状态有重复的数字，那么就可以想象成全排列了也就是n!。于是代码可以写成下面的，而复杂度也就变成了O(n*n!)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==n+<span class="number">1</span>) &#123;update_answer(); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        rec[depth]=i,used[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!used[i]) dfs(depth+<span class="number">1</span>);</span><br><span class="line">        rec[depth]=<span class="number">0</span>,used[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变全排列为组合，进一步降低时间复杂度"><a href="#变全排列为组合，进一步降低时间复杂度" class="headerlink" title="变全排列为组合，进一步降低时间复杂度"></a>变全排列为组合，进一步降低时间复杂度</h4><p>　　如果再添加限制条件，使选择顺序和答案无关，时间上就变成了一个组合问题，也就是前面已经出现过的状态，后面就不要再出现了。<font style="color:red;">深搜中剪枝优化的本质就是通过减少不必要的状态数来减少程序的运行时间，</font><font style="color:yellow;">而记忆化搜索则通过减少重复计算的等价状态数来减少程序的运行时间。</font>受限于极高的时间复杂度，每个状态对应消耗的时间往往原本就很短，通常不具备优化潜力。看下面的代码，也就是说前面已经填了的数，后面就不要再填了，这样就能保证只有一种状态了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==n+<span class="number">1</span>)&#123;update_answer(); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        rec[depth]=i;</span><br><span class="line">        dfs(depth+<span class="number">1</span>,i);</span><br><span class="line">        rec[depth]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>动态规划和记忆化搜索之所以快于深搜的本质</strong>就在于它们极大地减少了需要计算的状态数，避免了大量的重复计算。动态规划的一大要求，就是状态的无后效性——这就意味着对之后的状态来说，之前的所有导致这个状态发生的路径都是等价的。</p>
<h4 id="一个分析递归时间复杂度的例子"><a href="#一个分析递归时间复杂度的例子" class="headerlink" title="一个分析递归时间复杂度的例子"></a>一个分析递归时间复杂度的例子</h4><p>　　下面是一个分析递归时间复杂度的例子，这个例子其实也不难理解，首先要看有多少个状态数，或者可以想象成每层递归会产生多少个中间结果，然后每个状态的时间复杂度也就只有一行代码，所以每个状态的时间复杂度好确定，也就是O(2)，然后就要确定状态数，不好想的话也可以直接思考那行代码执行了多少次啊。首先看他每个状态都会产生两个后继，递归d层的话也就是$2^d$成指数增长，然后看到了x/2，每次数据规模都会除以2，那么递归的次数就好确定了，就是O(logn)层了，所以总的时间复杂度就是O($2^{logn}$),也就是O(n)。</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>　　均摊时间复杂度：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度较高。而且这些操作之间存在前后连贯的时序关系，在这个时候，我们可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度较低的操作上。（<strong>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度</strong>）</p>
<p>　　这个其实也好理解，也就是达到某个条件之后开始进入循环，然后此时的时间复杂度突然变化很大，这个时候利用加权平均法推导一下，利用大O记号约掉常数项和系数就可以得到最后的结果，举例的话可以看参考链接中的均摊时间复杂度。</p>
<h3 id="分治的时间复杂度"><a href="#分治的时间复杂度" class="headerlink" title="分治的时间复杂度"></a>分治的时间复杂度</h3><p>　　在遇到因状态不同而导致时间复杂度不同的情况时，需要进行分类处理，也就是每一次递归的数据的状态差异较大时。如下面的分治法的列子，对于递归过程的第i层，一共有$2^i$个状态，这里还可以套用之前的公式，一共有$\frac{n}{2^i}$个状态，</p>
<p>　　以上这些在《算法导论》中都有比较详细的讲解，等有空再好好拜读一下。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.acwing.com/blog/content/1851/" target="_blank" rel="noopener">由算法范围反推时间复杂度</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTAzMzQ5NA==&amp;mid=2650840595&amp;idx=1&amp;sn=e1d3feab66e311b835b3850f580b1b22&amp;chksm=846f1e6ab318977cdc451302f4f2cd1ba34062409209b17e3eb8d6afee7d9d06340ddea8d0ec&amp;mpshare=1&amp;scene=23&amp;srcid=0420dFq9damQ0iuLFTfNRbTk&amp;sharer_sharetime=1587314213571&amp;sharer_shareid=45cbbec5e51a7e07c18cb11ee6f38ad0#rd" target="_blank" rel="noopener">时间复杂度分析快速入门</a></p>
<p><a href="https://www.cnblogs.com/hardyyao/p/9744427.html" target="_blank" rel="noopener">浅析最好、最坏、平均、均摊时间复杂度</a></p>
]]></content>
      <categories>
        <category>数据结构与算法C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建站过程</title>
    <url>/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>nodejs、本地Git bash安装、github注册等等这些之前在学习vue的时候都已经配置过了，所以我一上来就是直接配置Hexo的。</p>
<h2 id="本地搭建Hexo步骤"><a href="#本地搭建Hexo步骤" class="headerlink" title="本地搭建Hexo步骤"></a>本地搭建Hexo步骤</h2><h3 id="npm安装hexo"><a href="#npm安装hexo" class="headerlink" title="npm安装hexo"></a>npm安装hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p><strong><font style="color:red;">重点hexo安装慢和后面hexo init初始化慢的坑</font>：就是要给npm换源，换成国内的镜像源，我用过下面两种方法，建议第二种，因为后面初始化hexo init是要用npm的</strong></p>
<ul>
<li><p>使用阿里定制的 cnpm 命令行工具代替默认的 npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接把npm换为淘宝源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>输入<code>npm config list</code>可以查看是否换源成功</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414215447453.png" alt="image-20200414215447453.png"></p>
</li>
</ul>
<p>安装好了hexo后，接下来要先初始化一个本地项目，这点有点类似于git的操作。</p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><ul>
<li><p>首先我是先找了一个比较空的不常用的磁盘作为我的博客的建站地点，然后右击git bash打开git的命令行，并执行一下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p><strong>这个地方需要注意，可能到某个地方下载的特别慢，但是如果前面切换了npm，应该很快就好了，我当时觉得感觉到卡住了，所以搜了一下，但是删除这个项目的时候说.git文件正在使用中，然后在配置好了npm镜像源之后果断重启了电脑，然后删掉了项目，重新执行上面的命令</strong></p>
<p>完成了之后会出现在本地下载好如下内容(确实有点像vue)，但是在接下来的各种操作，只需要关注下面几个文件夹就好了。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414194329012.png" alt="image-20200414194329012" style="zoom:80%;"></p>
</li>
<li><p>生成静态页面——-在以上文件夹的public中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动本地服务器——-<code>浏览器输入：http://localhost:4000/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭本地服务器——-<code>Ctrl+c</code></p>
<p><strong>以上命令都是在git bash，也就写git命令的地方执行。执行完以上操作，基本上就完成了本地hexo的搭建，但是他那个界面我不太喜欢，所以还是参考大神博客修改了一番，接下来就开始漫长的博客主题设置模块</strong></p>
</li>
</ul>
<h2 id="博客主题配置"><a href="#博客主题配置" class="headerlink" title="博客主题配置"></a>博客主题配置</h2><h3 id="克隆别人的主题"><a href="#克隆别人的主题" class="headerlink" title="克隆别人的主题"></a>克隆别人的主题</h3><p>在刚刚hexo init的项目根目录下找到themes文件夹，进去右击git bash，在此处clone别人的github中的主题，我用的是hexo-theme-next，后面有喜欢的主题我也会试着修改一下，暂时先用着这个，简洁清新，很不错~。当然还有很多好看的主题可以到这个页面<code>https://hexo.io/themes/</code>，点击一个喜欢的主题，然后进去点击人家的github链接，复制github中的链接同样的命令克隆到themes文件夹下即可。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>  下载可能需要等一会，这个等候是在自己的承受范围的哈哈哈，毕竟github是国外的，速度比较慢。下载完在themes文件夹下会多出一个文件夹，建议把这些文件夹先搞明白，不管我们写什么项目，先把常用的文件夹弄清楚我觉得是很有必要的，虽然我一开始被弄得有点乱，但是现在回想起来好像也就那几个目录常用。</p>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><ul>
<li><p>现在要回到刚刚hexo init的根目录下，然后用记事本打开_config.yml文件，我是用的nodepad++打开的，有高亮而且格式不会乱。这个yml接下来会常用到，毕竟是配置文件，和springboot中的配置文件一样，之前了解过，在启动的时候会自己加载。</p>
</li>
<li><p>然后notepad++中<code>Ctrl+f</code>，搜索theme，然后修改为刚刚的克隆的主题的名称</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414200852111.png" alt="image-20200414200852111" style="zoom:80%;"></p>
</li>
</ul>
<h3 id="切换主题风格"><a href="#切换主题风格" class="headerlink" title="切换主题风格"></a>切换主题风格</h3><ul>
<li><p>这个主题包中应该是自带了几种风格的，进入到这个包中，可以看到如下文件，当然也并不是全部用得到。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414201943868.png" alt="image-20200414201943868" style="zoom: 67%;"></p>
</li>
<li><p>进入配置文件修改主题风格，用notepad++打开改目录下的_config.yml，<strong>建议notepad++在整个过程中就不要关闭了，而且要记住这两个配置文件，哪个是项目根目录的配置文件，哪个是克隆的主题包的配置文件。</strong></p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414203008492.png" alt="image-20200414203008492" style="zoom:67%;"></p>
</li>
<li><p>然后修改主题风格如下，人家包中就注释好了几种，只要稍微改一下就好了，直接<code>Ctrl+f</code>搜索<code>scheme</code>，这里我用的是下面的风格</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414203200798.png" alt="image-20200414203200798" style="zoom:80%;"></p>
</li>
</ul>
<h3 id="博客左侧导航栏设置"><a href="#博客左侧导航栏设置" class="headerlink" title="博客左侧导航栏设置"></a>博客左侧导航栏设置</h3><ul>
<li>进入根目录的_config.yml，打开后在最上面可以修改博客的导航栏</li>
</ul>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414204645233.png" alt="image-20200414204645233" style="zoom:80%;"></p>
<ul>
<li><p>注意一下language是切换语言为中文的，其他的直接看下效果就好了</p>
</li>
<li><p>导航栏从上往下来，下面就是专栏的设计，也就是首页和归档等，这里我先添加两个专栏，一个是分类，一个是标签。</p>
<h4 id="分类专栏"><a href="#分类专栏" class="headerlink" title="分类专栏"></a><strong>分类专栏</strong></h4><ul>
<li><p>回到项目的根目录下，也就是刚刚hexo init生成的目录，然后在这里右击git bash，输入下面的命令，就会在项目根目录的source文件夹下自动创建一个categories文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开categories文件夹中的index.md文件，添加下面一行，<font style="color:red;"><strong>冒号后面要有个空格</strong></font></p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414205701409.png" alt="image-20200414205701409"></p>
</li>
<li><p>然后到<code>MyBlog\themes\hexo-theme-next</code>主题文件夹下的_config.xml中，<code>Ctrl+f</code>搜索menu，然后把categories一行取消注释，也就是去掉前面的#。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414210210966.png" alt="image-20200414210210966" style="zoom:80%;"></p>
</li>
<li><p>将文章添加到分类——后面会详细说一下发布文章的整个步骤，这就先提一下，也就是在md文档的最顶端添加一行即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: 建站</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="标签专栏"><a href="#标签专栏" class="headerlink" title="标签专栏"></a><strong>标签专栏</strong></h4><ul>
<li><p>和分类专栏步骤差不多，首先在根目录下执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开tags文件夹中的index.md文件,添加一行</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414210713648.png" alt="image-20200414210713648"></p>
</li>
<li><p>然后到主题文件夹下的配置文件中取消注释的tags一行即可</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414210821050.png" alt="image-20200414210821050" style="zoom:80%;"></p>
</li>
<li><p>给文章添加标签，需要注意文章可能有多个标签，所以要用以下方式,记得-后面有个空格！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">	- Hexo</span><br><span class="line">	- Github</span><br><span class="line">	- 腾讯云域名</span><br><span class="line">	- Windows</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加到文章的标签样式，默认标签在文章最下面，标签前面有一个#，要改成一个图标才好看，所以要进去主题文件夹下<code>\MyBlog\themes\hexo-theme-next\layout\_macro</code>，打开post.swig文件，这个文件就类似于我们的HTML文件，进去后<code>Ctrl+f</code>搜索<code>tag_indicate</code>,这里不知道为啥他用了if判断，我根据我的直觉，直接把带有#的那部分删掉了，也就是一出来就让他显示那个图标签的图标就好。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414225232228.png" alt="image-20200414225232228" style="zoom: 67%;"></p>
<h4 id="站内搜索专栏"><a href="#站内搜索专栏" class="headerlink" title="站内搜索专栏"></a><strong>站内搜索专栏</strong></h4></li>
<li><p>这个地方按照别人的博客来搞，最后部署的时候竟然会出现以下问题，显示乱了，在本地访问是没有问题的。<strong>可能是因为我安装的时候不是在根目录下安装的插件</strong></p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414212415442.png" alt="image-20200414212415442" style="zoom:67%;"></p>
<p><strong>解决方法:</strong>在hexo init的项目根目录下，按住shift键右击鼠标，然后在这里打开powershell命令行，然后执行下面的命令，安装站内搜索插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414212727263.png" alt="image-20200414212727263"></p>
</li>
<li><p>按装好了后在项目根目录的_config.yml文件的最下面添加下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入主题文件夹的_config.yml文件，<code>Ctrl+f</code>搜索<code>local_search</code>，设置enable为true</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414213131759.png" alt="image-20200414213131759" style="zoom:80%;"></p>
<h4 id="个人头像设置"><a href="#个人头像设置" class="headerlink" title="个人头像设置"></a><strong>个人头像设置</strong></h4></li>
<li><p>打开主题文件夹下的_config.yml,然后<code>Ctrl+f</code>搜索<code>avatar</code>，然后把一个头像链接替换即可。</p>
</li>
<li><p><strong><font style="color:red;">这里头像链接的一定要注意</font></strong></p>
<p>需要在hexo init项目根目录的source文件夹下新建一个images文件夹，然后把图片放到里面，然后在填写路径的时候，直接写相对路径<code>&quot;/images/1.jpg&quot;</code>，</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414230547359.png" alt="image-20200414230547359" style="zoom:80%;"></p>
<p>我通过调试工具发现，开启服务器后，<code>http://localhost:4000/</code>所请求到的文件夹就是项目根目录的source文件夹，所以上面直接从images目录写就好了。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414230705922.png" alt="image-20200414230705922" style="zoom:80%;"></p>
</li>
<li><p>给头像加样式，设置旋转以及圆角(因为我的头像是长方形，所以就不设置圆角了)，进入主题文件夹下的<code>\MyBlog\themes\hexo-theme-next\source\css\_common\components</code>目录，打开<code>components.styl</code>，在这里需要解释一波，这里的.styl文件，就和HTML的样式表文件.css文件是同样的效果！然后我们在这个文件下面加入下面的代码，就可以实现圆角和hover时旋转360°了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">#333</span>sf;</span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@-moz-keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(-<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后重启服务器，可以看到经过以上配置后，博客左侧导航栏的初步样式，当然也可以边设置边重新启动来看效果。重启的步骤就是先<code>Ctrl+c</code>关闭服务器，如果正在运行的话，然后hexo g重新生成静态文件，最后hexo s启动服务器，以上两个命令如果没有效果可以先hexo clean一波，然后再试</strong>。效果如下：</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414231818624.png" alt="image-20200414231818624" style="zoom:67%;"></p>
<h3 id="博客底部设置"><a href="#博客底部设置" class="headerlink" title="博客底部设置"></a>博客底部设置</h3></li>
</ul>
<h4 id="去掉底部自带的Hexo链接"><a href="#去掉底部自带的Hexo链接" class="headerlink" title="去掉底部自带的Hexo链接"></a>去掉底部自带的Hexo链接</h4><ul>
<li><p>打开<code>MyBlog\themes\hexo-theme-next\layout\_partials</code>下的footer.swig，这个文件就相当于html文件，然后我是把下面那部分内容去掉了</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414235113905.png" alt="image-20200414235113905" style="zoom:80%;"></p>
</li>
</ul>
<h4 id="网站底部字数统计设置"><a href="#网站底部字数统计设置" class="headerlink" title="网站底部字数统计设置"></a>网站底部字数统计设置</h4><ul>
<li><p>在项目根目录下安装 hexo 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>MyBlog\themes\hexo-theme-next\layout\_partials</code>下的footer.swig，在文末添加下面的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>博客全站共&#123;&#123; totalcount(site) &#125;&#125;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="网站底部站点访问量和访问人数"><a href="#网站底部站点访问量和访问人数" class="headerlink" title="网站底部站点访问量和访问人数"></a>网站底部站点访问量和访问人数</h4><p>​        <strong>需要注意的是，访问次数和浏览量在本地服务器会出现次数非常大的状况，这是小问题，只要部署在github之后，就不会有这个问题啦</strong></p>
<ul>
<li><p>网站底部字数统计设置已经安装了插件，这里不需要再装</p>
</li>
<li><p>然后打开<code>MyBlog\themes\hexo-theme-next\layout\_partials</code>下的footer.swig，在文末添加下面的代码，<strong>这段代码加在字数统计的上面</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user-md"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span></span><br><span class="line">    本站访问量:<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span><br><span class="line">    本站总访客量：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200414235846523.png" alt="image-20200414235846523" style="zoom: 67%;"></p>
</li>
</ul>
<h3 id="文章阅读次数设置"><a href="#文章阅读次数设置" class="headerlink" title="文章阅读次数设置"></a>文章阅读次数设置</h3><p><strong>我参考的博客中的方法是不行的</strong>，而且我查阅了很多博客几乎都是这样，都不行。也就是说<strong>不用把busuanzi_count:设置为true</strong>，只是用HTML的代码就可以实现了。</p>
<p><strong>解决方法：</strong>找到<code>MyBlog\themes\hexo-theme-next\layout\_macro</code>下的post.swig，根据我的理解，这就是每篇文章的布局，相当于文章的HTML文件，然后我进去找，凭借感觉真的发现了问题所在，原来在if判断的时候出了问题，我也是歪打正着，下面删掉了判断中的部分就好了</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415000958172.png" alt="image-20200415000958172"></p>
<p><strong>以上是我在配置博客主题的时候遇到问题的地方吧，文章最后会给出参考链接，链接中给我遇到问题的地方都已经给出了，还有一些我没有用到的效果，可以自行使用，问题不大！！！</strong></p>
<h2 id="部署到github远程仓库"><a href="#部署到github远程仓库" class="headerlink" title="部署到github远程仓库"></a>部署到github远程仓库</h2><h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><p>这里需要注意创建仓库的名称一定要是<code>你的github名称.github.io</code></p>
<h3 id="链接到本地hexo"><a href="#链接到本地hexo" class="headerlink" title="链接到本地hexo"></a>链接到本地hexo</h3><ul>
<li><p>复制github仓库的链接</p>
</li>
<li><p>打开项目根目录的_config.yml文件，<code>Ctrl+f</code>搜索<code>deploy</code>，<strong>tpye</strong> 设置为 <strong>git</strong>，<strong>repo</strong> 则设置为刚刚新建的远程仓库链接。</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415003907761.png" alt="image-20200415003907761" style="zoom:80%;"></p>
</li>
<li><p>然后在项目根目录下安装插件，<strong>记住一定是根目录！！！前面好几处错误都不是根目录导致的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在根目录下执行代码部署到github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #这句是清除所有本地的静态文件</span><br><span class="line">hexo g  #再生成所有静态文件</span><br><span class="line">hexo d  #部署到远程仓库</span><br></pre></td></tr></table></figure>
<p>然后就可以看到github仓库中有了内容，但是这样还不行，这样访问链接的话是没有一点样式的，还需要在本地hexo项目根目录下的_config.ym文件中，<code>Ctrl+f</code>搜索url，然后把github仓库的setting中的链接填写到下面的位置</p>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415004808091.png" alt="image-20200415004808091" style="zoom: 50%;"></p>
</li>
</ul>
<p><img src="/2020/04/14/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/image-20200415004858384.png" alt="image-20200415004858384" style="zoom: 67%;"></p>
<ul>
<li>然后再重新部署整个项目，即可看到成功搭建完成了！！！最后需要注意，当你hexo d之后会发现自己的网站并没有及时更新，这时候可以再hexo d一遍，多刷新几下网站就出来啦！</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        总的来说，搭建个人博客的过程确实有点麻烦，可能还不如直接注册个别的博客来写，可是我觉得最大的好处就是这个写文章以及发表还有主题效果是真的好，最重要的这是个人博客！以后我会将自己在学习中所遇到的问题以及学到的新知识都会记录在这里，之前我都是记录在OneNote中，OneNote是我用了好几年的记笔记软件，但是它的格式什么的确实让我难受了许久(比如没有代码块等)。</p>
<p>​        我曾经也有过自己开发一个个人博客的想法,但是考虑到自己能力不足，也没有大块的时间去开发，而且部署在各大平台的云服务器还是要收费的，到期了就不能永久存留了，这个就一直拖再拖。直到我了解了hexo之后，我才发现用这个记笔记也是个很不错的选择，至少代码可以永久存在github。以后有时间的话我会把以前记录在OneNote的所有笔记整理到这里来，既可以温故而知新，又可以多备份一份笔记，防止笔记丢失了哈哈哈哈！！！</p>
<h2 id="本文参考链接"><a href="#本文参考链接" class="headerlink" title="本文参考链接"></a>本文参考链接</h2><p><a href="https://blog.csdn.net/weidong_y/article/details/90904781" target="_blank" rel="noopener">建站参考链接</a></p>
<p><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">Markdown图片无法显示</a>,建议设置编辑器的图片存储路径，就可以直接贴图了</p>
<p><a href="https://blog.csdn.net/yexiaohhjk/article/details/82526604" target="_blank" rel="noopener">解决无法显示数学公式</a></p>
<p><a href="https://blog.csdn.net/TomAndersen/article/details/104872852" target="_blank" rel="noopener">背景图片问题</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>OneNote突然打不开</title>
    <url>/2020/05/02/OneNote%E7%AA%81%E7%84%B6%E6%89%93%E4%B8%8D%E5%BC%80/</url>
    <content><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>重点是要先卸载</strong></p>
<ul>
<li><p>卸载原来的OneNote。这个真的被我忽略了哦！看了网上一大堆，通过什么命令行就给卸载了，我真的是被坑了好久哦，就算执行命令也得先从电脑上卸载了哦，但是本人没有装360等电脑管家，然后从控制面板卸载也没找到，还好最后从左边的菜单栏右击可以删除了。</p>
<p><img src="/2020/05/02/OneNote%E7%AA%81%E7%84%B6%E6%89%93%E4%B8%8D%E5%BC%80/image-20200502110131585.png" alt="image-20200502110131585" style="zoom:80%;"></p>
</li>
<li><p>卸载之后就可以执行命令行</p>
<p>右键点击开始菜单&gt;&gt;搜索&gt;&gt;powershell&gt;&gt;右键管理员运行</p>
<p>输入Get-AppxPackage <em>OneNote</em> | Remove-AppxPackage</p>
</li>
<li><p>然后进入应用商店重新安装就可以了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Windows问题</category>
      </categories>
      <tags>
        <tag>OneNote</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习记录</title>
    <url>/2020/05/01/numpy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="numpy方法"><a href="#numpy方法" class="headerlink" title="numpy方法"></a>numpy方法</h2><h3 id="np-copysign-x-y"><a href="#np-copysign-x-y" class="headerlink" title="np.copysign(x,y)"></a>np.copysign(x,y)</h3><p>将数组y中各元素值的符号赋值给数组x对应元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">-10</span>,+<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">print(Z)</span><br><span class="line"><span class="keyword">print</span> (np.copysign(np.ceil(np.abs(Z)), Z))<span class="comment">#从零位对浮点数组做舍入</span></span><br><span class="line">print(np.floor(Z))</span><br></pre></td></tr></table></figure>
<h3 id="np-intersect1d"><a href="#np-intersect1d" class="headerlink" title="np.intersect1d"></a>np.intersect1d</h3><p>找到两个数组中共同的元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Z1 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">Z2 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">print(np.intersect1d(Z1,Z2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>给任务排序---拓扑排序</title>
    <url>/2020/05/11/%E7%BB%99%E4%BB%BB%E5%8A%A1%E6%8E%92%E5%BA%8F-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例输入：</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">样例输出：</span></span><br><span class="line"><span class="comment">1 4 2 5 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法入门</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1060 Are They Equal</title>
    <url>/2020/08/14/PAT-A1060-Are-They-Equal/</url>
    <content><![CDATA[<h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p><strong>解题思路：</strong>此题应该分两步走，分别确定指数和转为有效数位标准格式，确定指数应该根据小数点的位置来确定。小数点前面有几个整数，指数就为几；小数点后面要看第一个整数前面有几个0，有几个0就为负几。确定有效数位，从第一个整数开始，数n个数，如果缺数，用0补齐。</p>
<p><strong>需要注意的c++语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--&gt;1、e不能直接作为if判断条件，正负为true，0位false</span></span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">if</span>(e&gt;<span class="number">0</span>) f=p-e;</span><br><span class="line"><span class="keyword">else</span> f=p-e+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"f:"</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//--&gt;2、string的append添加字符的时候有两个参数，//string也可以直接+=字符！</span></span><br><span class="line">res.append(<span class="number">1</span>,<span class="string">'0'</span>);</span><br><span class="line">res+=<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//--&gt;3、数字转字符串在devc++中不能用to_string,可以用下面的方法</span></span><br><span class="line">	<span class="comment">//整数转string </span></span><br><span class="line">    <span class="comment">//	char chs[100];</span></span><br><span class="line">    <span class="comment">//	sprintf(chs,"%d",e);</span></span><br><span class="line">    <span class="comment">//	string st(chs,chs+strlen(chs));</span></span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss&lt;&lt;e;</span><br><span class="line">    <span class="built_in">string</span> st=ss.str(); </span><br><span class="line">    res+=st;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定指数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findP</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=s.length();</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//如果小数点存在，根据小数点确定指数 </span></span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">'.'</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> p=s.<span class="built_in">find</span>(<span class="string">'.'</span>);</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> beforeHas=<span class="literal">false</span>;<span class="comment">//判断小数点前面有无整数</span></span><br><span class="line">		<span class="keyword">bool</span> afterHas=<span class="literal">true</span>;<span class="comment">//判断小数点后面有无整数 </span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;p)&#123;<span class="comment">//找出小数点前面的第一个整数位置 </span></span><br><span class="line">			<span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">				beforeHas=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> i++;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;p&lt;&lt;endl&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">		res=p-i; </span><br><span class="line">		i=p+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!beforeHas)&#123;</span><br><span class="line">			<span class="keyword">while</span>(i&lt;l)&#123;<span class="comment">//找出小数点后面第一个整数前面0的位数</span></span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)&#123;</span><br><span class="line">					res--;</span><br><span class="line">					afterHas=<span class="literal">false</span>;</span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					afterHas=<span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; </span><br><span class="line">				i++;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!afterHas)&#123;</span><br><span class="line">			res=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//如果没有小数点，就找第一个整数位置</span></span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(j&lt;l)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j]!=<span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> j++;</span><br><span class="line">		&#125; </span><br><span class="line">		res=l-j; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//转为标准格式</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">changeTo</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> n,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res=<span class="string">"0."</span>;</span><br><span class="line">	<span class="keyword">int</span> len=s.length(); </span><br><span class="line">	<span class="comment">//判断有无小数点 </span></span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">'.'</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">		<span class="keyword">int</span> p=s.<span class="built_in">find</span>(<span class="string">'.'</span>);</span><br><span class="line">		<span class="comment">//找到第一个有效位数 </span></span><br><span class="line">		<span class="keyword">int</span> f;</span><br><span class="line">		<span class="keyword">if</span>(e&gt;<span class="number">0</span>) f=p-e;<span class="comment">//小数点前后开始位置不同 </span></span><br><span class="line">		<span class="keyword">else</span> f=p-e+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;"f:"&lt;&lt;f&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;)&#123;</span><br><span class="line">			<span class="keyword">if</span>(f&lt;len)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[f]))&#123;</span><br><span class="line">					res.append(<span class="number">1</span>,s[f]);</span><br><span class="line">					f++;</span><br><span class="line">					i++;	</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					f++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				res.append(<span class="number">1</span>,<span class="string">'0'</span>);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;len&amp;&amp;t&lt;n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">				res.append(<span class="number">1</span>,s[j]);</span><br><span class="line">				j++;</span><br><span class="line">				t++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(t&lt;n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;len)&#123;</span><br><span class="line">				res.append(<span class="number">1</span>,s[j]);</span><br><span class="line">				j++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				res.append(<span class="number">1</span>,<span class="string">'0'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			t++;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	res+=<span class="string">"*10^"</span>;</span><br><span class="line">	<span class="comment">//整数转string </span></span><br><span class="line"><span class="comment">//	char chs[100];</span></span><br><span class="line"><span class="comment">//	sprintf(chs,"%d",e);</span></span><br><span class="line"><span class="comment">//	string st(chs,chs+strlen(chs));</span></span><br><span class="line">	<span class="built_in">stringstream</span> ss;</span><br><span class="line">	ss&lt;&lt;e;</span><br><span class="line">	<span class="built_in">string</span> st=ss.str(); </span><br><span class="line">	res+=st;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; </span><br><span class="line">	<span class="built_in">string</span> s1,s2;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> e1=findP(s1);</span><br><span class="line">	<span class="keyword">int</span> e2=findP(s2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> ss1=changeTo(s1,n,e1);</span><br><span class="line">	<span class="built_in">string</span> ss2=changeTo(s2,n,e2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ss1==ss2)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES "</span>&lt;&lt;ss1;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO "</span>&lt;&lt;ss1&lt;&lt;<span class="string">" "</span>&lt;&lt;ss2;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法笔记解法"><a href="#算法笔记解法" class="headerlink" title="算法笔记解法"></a>算法笔记解法</h2><p><strong>解题思路：</strong>巧妙利用string的erase方法，将前导零和小数点去掉。也是寻找指数和有效位，先根据小数点寻找指数，最后确定有效位数，在寻找指数的过程中将小数点和零从字符串中清除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span>&amp; e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'0'</span>) s.erase(s.<span class="built_in">begin</span>());<span class="comment">//删除前导0</span></span><br><span class="line">	<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'.'</span>)&#123;<span class="comment">//如果下一个是小数点，该数小于1，e为负的 </span></span><br><span class="line">		s.erase(s.<span class="built_in">begin</span>());<span class="comment">//删除小数点</span></span><br><span class="line">		<span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'0'</span>)&#123;<span class="comment">//删除小数点后面的0，有几个零e为负几</span></span><br><span class="line">			 e--;</span><br><span class="line">			 s.erase(s.<span class="built_in">begin</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果下一个是整数，则找到小数点，判断小数点前面有几个整数，确定e </span></span><br><span class="line">		<span class="keyword">while</span>(k&lt;s.length()&amp;&amp;s[k]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">			k++;</span><br><span class="line">			e++;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(k&lt;s.length()) s.erase(s.<span class="built_in">begin</span>()+k);<span class="comment">//删除小数点 </span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s.length()==<span class="number">0</span>) e=<span class="number">0</span>;<span class="comment">//全部为零 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找出有效位,不够的补0 </span></span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span>(num&lt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;s.length()) res+=s[k++];</span><br><span class="line">		<span class="keyword">else</span> res+=<span class="string">'0'</span>;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line">	<span class="keyword">int</span> e1=<span class="number">0</span>,e2=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	s3=deal(s1,e1);</span><br><span class="line">	s4=deal(s2,e2);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(e1==e2&amp;&amp;s3==s4)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES 0."</span>&lt;&lt;s3&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e1;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO 0."</span>&lt;&lt;s3&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e1&lt;&lt;<span class="string">" 0."</span>&lt;&lt;s4&lt;&lt;<span class="string">"*10^"</span>&lt;&lt;e2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1025 PAT Ranking</title>
    <url>/2020/08/16/PAT-A1025-PAT-Ranking/</url>
    <content><![CDATA[<h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p><strong>解题思路：</strong>这道题目本身不难，比较简单，边读取边排序，然后合并到一个vector上，并进行总排序，在排序和读取的过程中完善结构体！<font style="color:red;"><strong>但是这道题目有一个巨坑！就是注册学号可能是0开头的，所以一开始使用long long代表学号在打印的时候要注意前面补0，后来我换成了char 字符数组来表示！</strong></font>全部通过！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> lnums[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> num[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">int</span> frank;</span><br><span class="line">	<span class="keyword">int</span> loc;</span><br><span class="line">	<span class="keyword">int</span> lrank;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Stu a,Stu b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.score!=b.score) <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.num,b.num)&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Stu&gt; pre_vec;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;lnums[i];</span><br><span class="line">		<span class="built_in">vector</span>&lt;Stu&gt; vec;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lnums[i];j++)&#123;</span><br><span class="line">			Stu s;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s.num&gt;&gt;s.score;</span><br><span class="line">			s.loc=i+<span class="number">1</span>;</span><br><span class="line">			vec.push_back(s);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">		vec[<span class="number">0</span>].lrank=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> l=vec.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;l;k++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(vec[k<span class="number">-1</span>].score==vec[k].score)&#123;</span><br><span class="line">				vec[k].lrank=vec[k<span class="number">-1</span>].lrank;<span class="comment">//如果并列，当前排名等于前一个的排名 </span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				vec[k].lrank=k+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;Stu&gt; <span class="title">d_vec</span><span class="params">(vec.<span class="built_in">size</span>()+pre_vec.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">		merge(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),pre_vec.<span class="built_in">begin</span>(),pre_vec.<span class="built_in">end</span>(),d_vec.<span class="built_in">begin</span>(),cmp);</span><br><span class="line">		d_vec.swap(pre_vec);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 	cout&lt;&lt;"--------"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;lnums[i];</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		for(int j=0;j&lt;lnums[i];j++)&#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;res[i][j].num&lt;&lt;":"&lt;&lt;res[i][j].loc&lt;&lt;":"&lt;&lt;res[i][j].score</span></span><br><span class="line"><span class="comment">//			&lt;&lt;":"&lt;&lt;res[i][j].lrank&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"--------"&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) total+=lnums[i];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;total&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	pre_vec[<span class="number">0</span>].frank=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pl=pre_vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;pl;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pre_vec[k<span class="number">-1</span>].score==pre_vec[k].score)&#123;</span><br><span class="line">			pre_vec[k].frank=pre_vec[k<span class="number">-1</span>].frank;<span class="comment">//如果并列，当前排名等于前一个的排名 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			pre_vec[k].frank=k+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pl;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;pre_vec[i].num&lt;&lt;<span class="string">" "</span>&lt;&lt;pre_vec[i].frank&lt;&lt;<span class="string">" "</span>&lt;&lt;pre_vec[i].loc&lt;&lt;<span class="string">" "</span>&lt;&lt;pre_vec[i].lrank&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法笔记解法"><a href="#算法笔记解法" class="headerlink" title="算法笔记解法"></a>算法笔记解法</h2><p><strong>解题思路：</strong>使用数组，定义int型变量num，用来存放当前获取到考生人数。每读入一个考生的信息，就让num自增。这样每当读取完一个考场的考生信息(假设该考场有k个考生)后，这个考场的考生所对应的数组下标便为区间[num-k,num)。</p>
<p><strong>使用数组的时间复杂度比用vector以及merge排序合并要快了3倍左右。数组最长时间为42ms，我的解法是142ms左右。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> id[<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">int</span> frank;</span><br><span class="line">	<span class="keyword">int</span> loc;</span><br><span class="line">	<span class="keyword">int</span> lrank;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line">Stu stus[<span class="number">30010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Stu a,Stu b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.score!=b.score) <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id)&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,num=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,stus[num].id,&amp;stus[num].score);</span><br><span class="line">			stus[num].loc=i;</span><br><span class="line">			num++; </span><br><span class="line">		&#125;		</span><br><span class="line">		sort(stus+num-m,stus+num,cmp);<span class="comment">//[num-m,num)</span></span><br><span class="line">		stus[num-m].lrank=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(stus[num-m+j].score==stus[num-m+j<span class="number">-1</span>].score) </span><br><span class="line">				stus[num-m+j].lrank=stus[num-m+j<span class="number">-1</span>].lrank;</span><br><span class="line">			<span class="keyword">else</span> stus[num-m+j].lrank=j+<span class="number">1</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	sort(stus,stus+num,cmp);</span><br><span class="line">	stus[<span class="number">0</span>].frank=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;num;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(stus[j].score==stus[j<span class="number">-1</span>].score) </span><br><span class="line">			stus[j].frank=stus[j<span class="number">-1</span>].frank;</span><br><span class="line">		<span class="keyword">else</span> stus[j].frank=j+<span class="number">1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s %d %d %d\n"</span>,stus[i].id,stus[i].frank,stus[i].loc,stus[i].lrank);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1032 Sharing</title>
    <url>/2020/08/18/PAT-A1032-Sharing/</url>
    <content><![CDATA[<h2 id="我的解法：想复杂了！！！"><a href="#我的解法：想复杂了！！！" class="headerlink" title="我的解法：想复杂了！！！"></a>我的解法：想复杂了！！！</h2><p><strong>解题思路：</strong>使用静态链表，先遍历第一个单词，然后遍历过的标志位flag设为1，并判断第一个是否含有环，有环的话就为-1，没有环就遍历第二个字符串，如果遇到flag为1，就输出结果，同时也要判断是否有环，但是我的解法有两个测试点答案错误，只有22分，所以还需要完善！</p>
<p>我觉得可能的错误就是两个链中间有公共部分！解决办法是从第一个相同的位置，再遍历两个字符串，如果标志位不相同，还要进行判断，是跳过该字符继续判断后面的，直到-1，还是直接输出-1.</p>
<font style="color:red;">**注意：scanf使用%c是可以读入空格的，所以中间需要加空格**</font>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1,a2,n,x;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a1,&amp;a2,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;node[x].data&gt;&gt;node[x].next;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1=node[a1];</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(k!=n)&#123;<span class="comment">//如果形成环的话，就打印-1</span></span><br><span class="line">		node[n1.next].flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n1.next==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		n1=node[n1.next];</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n2=node[a2];</span><br><span class="line">	<span class="keyword">if</span>(k==n) <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;<span class="comment">//先看第一个字符串 </span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		k=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">while</span>(k!=n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[n2.next].flag==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(n2.next==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">			n2=node[n2.next];</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k==n) <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d"</span>,n2.next);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法笔记解法"><a href="#算法笔记解法" class="headerlink" title="算法笔记解法"></a>算法笔记解法</h2><p>解题思路：不需要判断是否有环，只要将两个字符串都遍历一遍就完成了。不要想太复杂。。。PAT这题目是真的恶心，测试用例该复杂的时候不复杂，不该复杂的时候0001也能当做1来输入，真tm恶心！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1,a2,n,x,next;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a1,&amp;a2,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>,&amp;x,&amp;c,&amp;next);</span><br><span class="line">		node[x].data=c;</span><br><span class="line">		node[x].next=next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n1=a1;</span><br><span class="line">	<span class="keyword">while</span>(n1!=<span class="number">-1</span>)&#123;<span class="comment">//如果形成环的话，就打印-1</span></span><br><span class="line">		node[n1].flag=<span class="number">1</span>;</span><br><span class="line">		n1=node[n1].next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n2=a2;</span><br><span class="line">	<span class="keyword">while</span>(n2!=<span class="number">-1</span>)&#123;<span class="comment">//如果形成环的话，就打印-1</span></span><br><span class="line">		<span class="keyword">if</span>(node[n2].flag==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		n2=node[n2].next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n2!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%05d"</span>,n2);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1059 Prime Factors</title>
    <url>/2020/08/18/PAT-A1059-Prime-Factors/</url>
    <content><![CDATA[<h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p><strong>解题思路：</strong>首先先求出素数表，然后，定义一个结构体factor，存放该数n的质因数的素数部分和指数部分。用n除以素数表得出该数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pnum=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> prime[pnum],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,cnt;</span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">(<span class="keyword">int</span> n1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;<span class="comment">//注意此处不能用i*i</span></span><br><span class="line">		<span class="keyword">if</span>(!p[i])&#123;</span><br><span class="line">			prime[num++]=i;</span><br><span class="line">			<span class="keyword">if</span>(num&gt;=n1) <span class="keyword">break</span>; </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)&#123;</span><br><span class="line">				p[j]=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Find_Prime(pnum);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;pnum;i++)&#123;</span></span><br><span class="line"><span class="comment">//		printf("i=%d:%d\n",i,prime[i]);</span></span><br><span class="line"><span class="comment">//	&#125; </span></span><br><span class="line">	ll m=n;</span><br><span class="line">	<span class="keyword">int</span> fnum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pnum&amp;&amp;prime[i]&lt;=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			fac[fnum].x=prime[i];</span><br><span class="line">			fac[fnum].cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">				fac[fnum].cnt++;</span><br><span class="line">				n/=prime[i];</span><br><span class="line">			&#125;</span><br><span class="line">			fnum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">break</span>;<span class="comment">//等于一的话直接中断循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;<span class="comment">//如果没有被根号n以内的质因子除尽</span></span><br><span class="line">		fac[fnum].x=n;<span class="comment">//那么一定只有一个大于根号n的质因子</span></span><br><span class="line">		fac[fnum++].cnt=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1=1"</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld="</span>,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fnum;i++)&#123;</span><br><span class="line">		    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,fac[i].x);</span><br><span class="line">            <span class="keyword">if</span>(fac[i].cnt&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"^%d"</span>,fac[i].cnt);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
